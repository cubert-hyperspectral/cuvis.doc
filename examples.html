

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Examples &mdash; Cuvis SDK 3.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/tabs.css?v=a5c4661c" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=eb155f5e"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/tabs.js?v=3030b3cb"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Cuvis C API" href="cwrapper.html" />
    <link rel="prev" title="SDK User’s Guide" href="sdkuserguide.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Cuvis SDK
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdkuserguide.html">SDK User’s Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#loading-a-measurment">Loading a Measurment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reprocessing-a-measurement">Reprocessing a Measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exporting-a-measurement">Exporting a Measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#changing-the-distance-of-a-measurement">Changing the Distance of a Measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recording-single-measurements">Recording single Measurements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recording-a-video">Recording a video</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rerecording-a-video-from-already-recorded-data">Rerecording a video from already recorded data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cwrapper.html">Cuvis C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="cppwrapper.html">Cuvis C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythonwrapper.html">Cuvis Python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Cuvis SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Examples</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/examples.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h1>
<section id="loading-a-measurment">
<h2>Loading a Measurment<a class="headerlink" href="#loading-a-measurment" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-0-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-0-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-0-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-0-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-0-Qw==" class="sphinx-tabs-panel group-tab" id="panel-0-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 3)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“sessionfile (.cu3s)n”);</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const sessionLoc = argv[2];</p>
<p>CUVIS_SESSION_FILE sess;
CUVIS_MESU mesu1;
unsigned chn;</p>
<p>unsigned x;
unsigned y;</p>
<p>const uint16_t* cube16bit;
//const uint16_t* info_ptr;</p>
<p>printf(“Example 01 load measurementn”);
printf(”nUser Settings Dir: “);
printf(userSettingsDir);
printf(”nsessionfile (.cu3s): “);
printf(sessionLoc);</p>
<p>printf(”nloading user settings…n”);
CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));
CUVIS_CHECK(cuvis_set_log_level(loglevel_info));</p>
<p>printf(“loading session…n”);
CUVIS_CHECK(cuvis_session_file_load(sessionLoc, &amp;sess));</p>
<p>printf(“loading measurement…n”);
CUVIS_CHECK(cuvis_session_file_get_mesu(</p>
<blockquote>
<div><p>sess, 0, session_item_type_frames_no_gaps, &amp;mesu1));</p>
</div></blockquote>
<p>CUVIS_MESU_METADATA mesu_data;
CUVIS_CHECK(cuvis_measurement_get_metadata(mesu1, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<dl class="simple">
<dt>assert(</dt><dd><p>mesu_data.processing_mode == Cube_Raw &amp;&amp;
“This example requires raw mode”);</p>
</dd>
</dl>
<p>CUVIS_IMBUFFER cube;
CUVIS_CHECK(</p>
<blockquote>
<div><p>cuvis_measurement_get_data_image(mesu1, CUVIS_MESU_CUBE_KEY, &amp;cube));</p>
</div></blockquote>
<p>CUVIS_IMBUFFER iminfo;
cuvis_measurement_get_data_image(mesu1, CUVIS_MESU_CUBE_INFO_KEY, &amp;iminfo);</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu1, &amp;mesu_data));
if (mesu_data.measurement_flags &amp; CUVIS_MESU_FLAG_OVERILLUMINATED)
{</p>
<blockquote>
<div><p>printf(”– is overilluminated –n”);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(”– is NOT overilluminated –n”);</p>
</div></blockquote>
<p>}</p>
<p>if (mesu_data.measurement_flags &amp; CUVIS_MESU_FLAG_POOR_REFERENCE)
{</p>
<blockquote>
<div><p>printf(”– has poor reference –n”);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(”– has GOOD reference –n”);</p>
</div></blockquote>
<p>}</p>
<p>printf(“INFO cube No of channels: %dn”, iminfo.channels);
printf(“INFO cube width: %dn”, iminfo.width);
printf(“INFO cube height: %dn”, iminfo.height);
printf(“DATA cube width: %dn”, cube.width);
printf(“DATA cube height: %dn”, cube.height);
printf(“INFO cube type: %dn”, iminfo.format);
printf(“INFO cube bytes: %dn”, iminfo.bytes);
printf(“DATA cube type: %dn”, cube.format);
printf(“DATA cube bytes: %dn”, cube.bytes);</p>
<dl class="simple">
<dt>assert(</dt><dd><p>cube.format == imbuffer_format_uint16 &amp;&amp;
“16 bit cube required for this example”);</p>
</dd>
</dl>
<p>//reinterpret as uint16
cube16bit = (const uint16_t*)(cube.raw);
//info_ptr = (const uint16_t*)(iminfo.raw);</p>
<p>x = 120;
y = 200;</p>
<p>assert(x &lt; cube.width &amp;&amp; “x index exceeds cube width”);
assert(y &lt; cube.height &amp;&amp; “x index exceeds cube width”);</p>
<p>printf(“lambda [nm]; raw counts [au]; pixel info n”);
for (chn = 0; chn &lt; cube.channels; chn++)
{</p>
<blockquote>
<div><p>// memory layout:
//unsigned index = (y * cube.width + x) * cube.channels + chn;
//uint16_t value = cube16bit[index];</p>
<p>uint16_t value = IMBUFFER_GET(cube16bit, x, y, chn, cube);
//only works with v3.X CUVIS data
//auto pixel_info = IMBUFFER_GET(info_ptr, x, y, 0, iminfo);
unsigned lambda = cube.wavelength[chn];</p>
<dl class="simple">
<dt>printf(</dt><dd><p>“%d; %d n”,
//”%d; %d; %d n”,
lambda,
value
//pixel_info);</p>
</dd>
</dl>
<p>);</p>
</div></blockquote>
<p>}
printf(” n”);</p>
<p>//for (x = 0; x &lt; cube.width; x++)
//{
//  for (y = 0; y &lt; cube.height; y++)
//  {
// memory layout:
//unsigned index = (y * cube.width + x) * cube.channels + chn;
//uint16_t value = cube16bit[index];</p>
<p>//auto pixel_info = IMBUFFER_GET(info_ptr, x, y, 0, iminfo);</p>
<p>//printf(“%d; “, pixel_info);
//  }
//  printf(” n”);
//}</p>
<p>cuvis_measurement_free(&amp;mesu1);
cuvis_session_file_free(&amp;sess);
cuvis_shutdown();
printf(“finished.n”);</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-0-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0"><p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;iostream&gt;</p>
<p>//#include &lt;opencv/opencv.hpp&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 3)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “Too few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile (.cu3s)” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const sessionLoc = argv[2];</p>
<p>std::cout &lt;&lt; “Example 01 load measurement cpp “ &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile (.cu3s): “ &lt;&lt; sessionLoc &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading user settings…” &lt;&lt; std::endl;
cuvis::General::init(userSettingsDir);
cuvis::General::set_log_level(loglevel_info);</p>
<p>std::cout &lt;&lt; “loading session… “ &lt;&lt; std::endl;
cuvis::SessionFile sess(sessionLoc);</p>
<p>std::cout &lt;&lt; “loading measurement… “ &lt;&lt; std::endl;
auto optmesu = sess.get_mesu(0);
assert(optmesu.has_value());
cuvis::Measurement mesu = optmesu.value();</p>
<dl class="simple">
<dt>std::cout &lt;&lt; “Data 1” &lt;&lt; mesu.get_meta()-&gt;name &lt;&lt; “ “</dt><dd><p>&lt;&lt; “t=” &lt;&lt; mesu.get_meta()-&gt;integration_time &lt;&lt; “ ms ”
&lt;&lt; “mode=” &lt;&lt; mesu.get_meta()-&gt;processing_mode &lt;&lt; “ “ &lt;&lt; std::endl;</p>
</dd>
</dl>
<p>if (mesu.get_meta()-&gt;measurement_flags.size() &gt; 0)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “  Flags” &lt;&lt; std::endl;
for (auto const&amp; flags : mesu.get_meta()-&gt;measurement_flags)
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “  - “ &lt;&lt; flags.first &lt;&lt; “ (” &lt;&lt; flags.second &lt;&lt; “)”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>assert(</dt><dd><p>mesu.get_meta()-&gt;processing_mode == Cube_Raw &amp;&amp;
“This example requires raw mode”);</p>
</dd>
</dl>
<p>auto const&amp; cube_it = mesu.get_imdata()-&gt;find(CUVIS_MESU_CUBE_KEY);
assert(cube_it != mesu.get_imdata()-&gt;end() &amp;&amp; “Cube not found”);</p>
<p>auto cube = std::get&lt;cuvis::image_t&lt;std::uint16_t&gt;&gt;(cube_it-&gt;second);</p>
<p>//uncomment to show a single channel with openCV
/*</p>
<blockquote>
<div><p>cv::Mat img(
cv::Size(cube._width, cube._height),
CV_16UC(cube._channels),
const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(cube._data)),
cv::Mat::AUTO_STEP);</p>
<p>cv::Mat singleChannel;
cv::extractChannel(</p>
<blockquote>
<div><p>img, singleChannel, 25); // extract channel 25 as an example</p>
</div></blockquote>
<p>singleChannel.convertTo(singleChannel, CV_8U, 1 / 16.0);
cv::imshow(“channel 25”, singleChannel);
cv::waitKey(0);
<a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</div></blockquote>
<p>std::size_t x = 120;
std::size_t y = 200;</p>
<p>assert(x &lt; cube._width &amp;&amp; “x index exceeds cube width”);
assert(y &lt; cube._height &amp;&amp; “y index exceeds cube height”);</p>
<p>std::cout &lt;&lt; “lambda [nm]; raw counts [au] “ &lt;&lt; std::endl;</p>
<p>for (std::size_t chn = 0; chn &lt; cube._channels; chn++)
{</p>
<blockquote>
<div><p>// memory layout:
//unsigned index = (y * cube.width + x) * cube.channels + chn;
//uint16_t value = cube16bit[index];</p>
<p>auto const value = cube.get(x, y, chn);
unsigned lambda = cube._wavelength[chn];</p>
<p>std::cout &lt;&lt; lambda &lt;&lt; “; “ &lt;&lt; value &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}
cuvis::General::shutdown();
std::cout &lt;&lt; “finished. “ &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-0-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
from pathlib import Path</p>
<p>import matplotlib.pyplot as plt
import numpy as np</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_loadMeasurement(</dt><dd><blockquote>
<div><p>userSettingsDir,
measurementLoc):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<p>print(“loading session…”)
session = cuvis.SessionFile(measurementLoc)</p>
<p>print(“loading measurement file…”)
mesu = session[0]
assert mesu._handle</p>
<dl>
<dt>print(“Data 1 {} t={}ms mode={}”.format(mesu.name,</dt><dd><p>mesu.integration_time,
mesu.processing_mode.name,
))</p>
</dd>
<dt>if isinstance(mesu.measurement_flags, cuvis.MeasurementFlags):</dt><dd><p>print(f”Flags: {mesu.measurement_flags}”)
for v in cuvis.MeasurementFlags.supremum():</p>
<blockquote>
<div><p>print(f’{v}: {v in mesu.measurement_flags}’)</p>
</div></blockquote>
</dd>
</dl>
<p>cube = mesu.cube
if cube is None:</p>
<blockquote>
<div><p>raise Exception(“Cube not found”)</p>
</div></blockquote>
<p>x = 120
y = 200</p>
<p>assert x &lt; cube.width, “x index exceeds cube width!”
assert y &lt; cube.height, “y index exceeds cube height!”</p>
<p>lambda_wl = []
raw_counts = []
for chn in np.arange(cube.channels):</p>
<blockquote>
<div><p>lambda_wl.append(cube.wavelength[chn])
raw_counts.append(cube.array[x, y, chn])</p>
</div></blockquote>
<p>plt.plot(lambda_wl, raw_counts)
plt.xlabel(“lambda [nm]”)
plt.ylabel(“raw counts [au]”)
plt.title(“Spectrum of {} for x={}, y={}”.format(mesu.name, x, y))
plt.show()</p>
<p>cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl class="simple">
<dt>if platform.system() == “Windows”:</dt><dd><dl class="simple">
<dt>data_dir = Path(os.getenv(“CUVIS”)).parent / “sdk” / </dt><dd><p>“sample_data” / “set_examples”</p>
</dd>
</dl>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><dl class="simple">
<dt>data_dir = Path(os.getenv(“CUVIS_DATA”)) / </dt><dd><p>“sample_data” / “set_examples”</p>
</dd>
</dl>
</dd>
</dl>
<p># default image
loc_file = data_dir / “set0_single” / “single.cu3s”</p>
<p># default settings
loc_settings = data_dir / “settings”</p>
<p>print(“Example 01: Load Measurement. Please provide:”)</p>
<dl class="simple">
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
<dt>measurementLoc = input(</dt><dd><p>“Measurement file (.cu3s) (default: {}): “.format(loc_file))</p>
</dd>
<dt>if measurementLoc.strip().lower() in [“”, “default”]:</dt><dd><p>measurementLoc = loc_file</p>
</dd>
</dl>
<p>run_example_loadMeasurement(str(userSettingsDir), str(measurementLoc))</p>
</div></blockquote>
</div></div>
</section>
<section id="reprocessing-a-measurement">
<h2>Reprocessing a Measurement<a class="headerlink" href="#reprocessing-a-measurement" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-1-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-1-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-1-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-1-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-1-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-1-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-1-Qw==" class="sphinx-tabs-panel group-tab" id="panel-1-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 7)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“measurement file (.cu3s)n”);
printf(“dark file (.cu3s)n”);
printf(“white file (.cu3s)n”);
printf(“distance file (.cu3s)n”);
printf(“Name of output directoryn”);</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const measurementLoc = argv[2];
char* const darkLoc = argv[3];
char* const whiteLoc = argv[4];
char* const distanceLoc = argv[5];
char* const outDir = argv[6];</p>
<p>printf(“Example 02 reprocess measurement n”);
printf(“user Settings Dir: “);
printf(userSettingsDir);
printf(”nmeasurement file (.cu3s): “);
printf(measurementLoc);
printf(”ndark file (.cu3s): “);
printf(darkLoc);
printf(”nwhite file (.cu3s): “);
printf(whiteLoc);
printf(”ndistance file (.cu3s): “);
printf(distanceLoc);
printf(”noutput Dir: “);
printf(outDir);</p>
<p>CUVIS_SESSION_FILE sessMesu;
CUVIS_SESSION_FILE sessDark;
CUVIS_SESSION_FILE sessWhite;
CUVIS_SESSION_FILE sessDistance;</p>
<p>CUVIS_MESU mesu;
CUVIS_MESU_METADATA mesu_data;
CUVIS_MESU dark;
CUVIS_MESU white;
CUVIS_MESU distance;</p>
<p>CUVIS_PROC_CONT procCont;</p>
<p>CUVIS_INT is_capable;</p>
<p>printf(”nloading settings… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));</p>
<p>printf(“loading sessionfiles… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_load(measurementLoc, &amp;sessMesu));
CUVIS_CHECK(cuvis_session_file_load(darkLoc, &amp;sessDark));
CUVIS_CHECK(cuvis_session_file_load(whiteLoc, &amp;sessWhite));
CUVIS_CHECK(cuvis_session_file_load(distanceLoc, &amp;sessDistance));</p>
<p>printf(“loading measurement… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_get_mesu(sessMesu, 0, session_item_type_frames_no_gaps, &amp;mesu));
CUVIS_CHECK(cuvis_session_file_get_mesu(sessDark, 0, session_item_type_frames_no_gaps, &amp;dark));
CUVIS_CHECK(cuvis_session_file_get_mesu(sessWhite, 0, session_item_type_frames_no_gaps, &amp;white));
CUVIS_CHECK(cuvis_session_file_get_mesu(sessDistance, 0, session_item_type_frames_no_gaps, &amp;distance));</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>printf(“Load processing context…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_create_from_session_file(sessMesu, &amp;procCont));</p>
<p>printf(“Set references …n”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_set_reference(procCont, dark, Reference_Dark));
CUVIS_CHECK(cuvis_proc_cont_set_reference(procCont, white, Reference_White));
CUVIS_CHECK(cuvis_proc_cont_set_reference(procCont, distance, Reference_Distance));</p>
<p>printf(“Prepare processing and export …n”);
CUVIS_PROC_ARGS args;
args.processing_mode = Cube_Raw;
args.allow_recalib = 0;
CUVIS_CHECK(cuvis_proc_cont_is_capable(procCont, mesu, args, &amp;is_capable));</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>CUVIS_EXPORT_CUBE_SETTINGS cube_settings;
cube_settings.allow_fragmentation = 0;
cube_settings.allow_overwrite = 1;
cube_settings.allow_session_file = 1;
cube_settings.operation_mode = OperationMode_Internal;
cube_settings.allow_info_file = 0;</p>
<p>if (1 == is_capable)
{</p>
<blockquote>
<div><p>printf(“reprocess measurement to Cube_Raw mode…n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, args));
CUVIS_CHECK(cuvis_proc_cont_apply(procCont, mesu));
printf(” done. n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>char exportDirRAW[CUVIS_MAXBUF];
strcpy(exportDirRAW, outDir);
strcat(exportDirRAW, “/RAW”);</p>
<p>strcpy(general_settings.export_dir, exportDirRAW);
CUVIS_EXPORTER cube_exporter;
CUVIS_CHECK(cuvis_exporter_create_cube(</p>
<blockquote>
<div><p>&amp;cube_exporter, general_settings, cube_settings));</p>
</div></blockquote>
<p>CUVIS_CHECK(cuvis_exporter_apply(cube_exporter, mesu));
cuvis_exporter_free(&amp;cube_exporter);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“Cannot process to Cube_Raw mode.n”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>args.processing_mode = Cube_DarkSubtract;
CUVIS_CHECK(cuvis_proc_cont_is_capable(procCont, mesu, args, &amp;is_capable));</p>
<p>if (1 == is_capable)
{</p>
<blockquote>
<div><p>printf(“reprocess measurement to Cube_DarkSubtract mode…”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, args));
CUVIS_CHECK(cuvis_proc_cont_apply(procCont, mesu));
printf(” done. n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>char exportDirDS[CUVIS_MAXBUF];
strcpy(exportDirDS, outDir);
strcat(exportDirDS, “/DS”);</p>
<p>strcpy(general_settings.export_dir, exportDirDS);
CUVIS_EXPORTER cube_exporter;
CUVIS_CHECK(cuvis_exporter_create_cube(</p>
<blockquote>
<div><p>&amp;cube_exporter, general_settings, cube_settings));</p>
</div></blockquote>
<p>CUVIS_CHECK(cuvis_exporter_apply(cube_exporter, mesu));
cuvis_exporter_free(&amp;cube_exporter);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“Cannot process to Cube_DarkSubtract mode.n”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>args.processing_mode = Cube_Reflectance;
CUVIS_CHECK(cuvis_proc_cont_is_capable(procCont, mesu, args, &amp;is_capable));</p>
<p>if (1 == is_capable)
{</p>
<blockquote>
<div><p>printf(“reprocess measurement to Cube_Reflectance mode…n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, args));
CUVIS_CHECK(cuvis_proc_cont_apply(procCont, mesu));
printf(” done. n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>char exportDirREF[CUVIS_MAXBUF];
strcpy(exportDirREF, outDir);
strcat(exportDirREF, “/REF”);</p>
<p>strcpy(general_settings.export_dir, exportDirREF);
CUVIS_EXPORTER cube_exporter;
CUVIS_CHECK(cuvis_exporter_create_cube(</p>
<blockquote>
<div><p>&amp;cube_exporter, general_settings, cube_settings));</p>
</div></blockquote>
<p>CUVIS_CHECK(cuvis_exporter_apply(cube_exporter, mesu));
cuvis_exporter_free(&amp;cube_exporter);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“Cannot process to Cube_Reflectance mode.n”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>args.processing_mode = Cube_SpectralRadiance;
CUVIS_CHECK(cuvis_proc_cont_is_capable(procCont, mesu, args, &amp;is_capable));</p>
<p>if (1 == is_capable)
{</p>
<blockquote>
<div><p>printf(“reprocess measurement to Cube_SpectralRadiance mode…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, args));
CUVIS_CHECK(cuvis_proc_cont_apply(procCont, mesu));
printf(” done. n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>char exportDirSPRAD[CUVIS_MAXBUF];
strcpy(exportDirSPRAD, outDir);
strcat(exportDirSPRAD, “/SPRAD”);</p>
<p>strcpy(general_settings.export_dir, exportDirSPRAD);
CUVIS_EXPORTER cube_exporter;
CUVIS_CHECK(cuvis_exporter_create_cube(</p>
<blockquote>
<div><p>&amp;cube_exporter, general_settings, cube_settings));</p>
</div></blockquote>
<p>CUVIS_CHECK(cuvis_exporter_apply(cube_exporter, mesu));
cuvis_exporter_free(&amp;cube_exporter);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“Cannot process to Cube_SpectralRadiance mode.n”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>cuvis_proc_cont_free(&amp;procCont);
cuvis_measurement_free(&amp;mesu);
cuvis_measurement_free(&amp;dark);
cuvis_measurement_free(&amp;white);
cuvis_measurement_free(&amp;distance);
cuvis_session_file_free(&amp;sessMesu);
cuvis_session_file_free(&amp;sessDark);
cuvis_session_file_free(&amp;sessWhite);
cuvis_session_file_free(&amp;sessDistance);
cuvis_shutdown();</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-1-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-1-Qysr" name="Qysr" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;iostream&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 7)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; std::endl &lt;&lt; “Too few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “measurement file (.cu3s)” &lt;&lt; std::endl;
std::cout &lt;&lt; “dark file (.cu3s)” &lt;&lt; std::endl;
std::cout &lt;&lt; “white file (.cu3s)” &lt;&lt; std::endl;
std::cout &lt;&lt; “distance file (.cu3s)” &lt;&lt; std::endl;
std::cout &lt;&lt; “Name of output directory” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const measurementLoc = argv[2];
char* const darkLoc = argv[3];
char* const whiteLoc = argv[4];
char* const distanceLoc = argv[5];
char* const outDir = argv[6];</p>
<p>std::cout &lt;&lt; “Example 02 reprocess measurement cpp “ &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “measurement file (.cu3s): “ &lt;&lt; measurementLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “dark file (.cu3s): “ &lt;&lt; darkLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “white file (.cu3s): “ &lt;&lt; whiteLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “distance file (.cu3s): “ &lt;&lt; distanceLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “output Dir: “ &lt;&lt; outDir &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading settings… “ &lt;&lt; std::endl;
cuvis::General::init(userSettingsDir);
cuvis::General::set_log_level(loglevel_info);</p>
<p>std::cout &lt;&lt; “loading measurement… “ &lt;&lt; std::endl;
cuvis::SessionFile sessMesu(measurementLoc);
auto optMesu = sessMesu.get_mesu(0);
assert(optMesu.has_value());
cuvis::Measurement mesu = optMesu.value();</p>
<p>std::cout &lt;&lt; “loading dark… “ &lt;&lt; std::endl;
cuvis::SessionFile sessDark(darkLoc);
auto optDark = sessDark.get_mesu(0);
assert(optDark.has_value());
cuvis::Measurement dark = optDark.value();</p>
<p>std::cout &lt;&lt; “loading white… “ &lt;&lt; std::endl;
cuvis::SessionFile sessWhite(whiteLoc);
auto optWhite = sessWhite.get_mesu(0);
assert(optWhite.has_value());
cuvis::Measurement white = optWhite.value();</p>
<p>std::cout &lt;&lt; “loading distance… “ &lt;&lt; std::endl;
cuvis::SessionFile sessDistance(distanceLoc);
auto optDistance = sessDistance.get_mesu(0);
assert(optDistance.has_value());
cuvis::Measurement distance = optDistance.value();</p>
<dl class="simple">
<dt>std::cout &lt;&lt; “Data 1” &lt;&lt; mesu.get_meta()-&gt;name &lt;&lt; “ “</dt><dd><p>&lt;&lt; “t=” &lt;&lt; mesu.get_meta()-&gt;integration_time &lt;&lt; “ ms ”
&lt;&lt; “mode=” &lt;&lt; mesu.get_meta()-&gt;processing_mode &lt;&lt; “ “ &lt;&lt; std::endl;</p>
</dd>
</dl>
<p>std::cout &lt;&lt; “Loading processing context” &lt;&lt; std::endl;
cuvis::ProcessingContext proc(sessMesu);</p>
<p>std::cout &lt;&lt; “Set references” &lt;&lt; std::endl;</p>
<p>proc.set_reference(dark, cuvis::reference_type_t::Reference_Dark);
proc.set_reference(white, cuvis::reference_type_t::Reference_White);
proc.set_reference(distance, cuvis::reference_type_t::Reference_Distance);</p>
<p>cuvis::ProcessingArgs procArgs;
cuvis::SaveArgs saveArgs;
saveArgs.allow_overwrite = true;
saveArgs.allow_session_file = true;
saveArgs.allow_info_file = false;</p>
<dl class="simple">
<dt>std::map&lt;std::string, cuvis::processing_mode_t&gt; target_modes = {</dt><dd><p>{“Raw”, cuvis::processing_mode_t::Cube_Raw},
{“DS”, cuvis::processing_mode_t::Cube_DarkSubtract},
{“Ref”, cuvis::processing_mode_t::Cube_Reflectance},
{“RAD”, cuvis::processing_mode_t::Cube_SpectralRadiance}};</p>
</dd>
</dl>
<p>for (auto const&amp; mode : target_modes)
{</p>
<blockquote>
<div><p>procArgs.processing_mode = mode.second;
if (proc.is_capable(mesu, procArgs))
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “processing to mode “ &lt;&lt; mode.first &lt;&lt; std::endl;
proc.set_processingArgs(procArgs);
proc.apply(mesu);
saveArgs.export_dir = std::filesystem::path(outDir) / mode.first;</p>
<p>cuvis::CubeExporter exporter(saveArgs);
exporter.apply(mesu);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “cannot process to mode “ &lt;&lt; mode.first &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
cuvis::General::shutdown();
std::cout &lt;&lt; “finished.” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-1-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-1-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
from pathlib import Path</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_reprocessMeasurement(</dt><dd><blockquote>
<div><p>userSettingsDir,
measurementLoc,
darkLoc,
whiteLoc,
distanceLoc,
outDir):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<p>print(“loading measurement file…”)
sessionM = cuvis.SessionFile(measurementLoc)
mesu = sessionM[0]
assert mesu._handle</p>
<p>print(“loading dark…”)
sessionDk = cuvis.SessionFile(darkLoc)
dark = sessionDk[0]
assert dark._handle</p>
<p>print(“loading white…”)
sessionWt = cuvis.SessionFile(whiteLoc)
white = sessionWt[0]
assert white._handle</p>
<p>print(“loading distance…”)
sessionDc = cuvis.SessionFile(distanceLoc)
distance = sessionDc[0]
assert distance._handle</p>
<dl class="simple">
<dt>print(“Data 1 {} t={}ms mode={}”.format(mesu.name,</dt><dd><p>mesu.integration_time,
mesu.processing_mode.name,
))</p>
</dd>
</dl>
<p>print(“loading processing context…”)
processingContext = cuvis.ProcessingContext(sessionM)</p>
<p>print(“set references…”)
processingContext.set_reference(dark, cuvis.ReferenceType.Dark)
processingContext.set_reference(white, cuvis.ReferenceType.White)
processingContext.set_reference(distance, cuvis.ReferenceType.Distance)</p>
<p>procArgs = cuvis.ProcessingArgs()
saveArgs = cuvis.SaveArgs(allow_overwrite=True,</p>
<blockquote>
<div><p>allow_session_file=True,
allow_info_file=False)</p>
</div></blockquote>
<dl class="simple">
<dt>modes = [cuvis.ProcessingMode.Raw,</dt><dd><p>cuvis.ProcessingMode.DarkSubtract,
cuvis.ProcessingMode.Reflectance,
cuvis.ProcessingMode.SpectralRadiance
]</p>
</dd>
</dl>
<p>for mode in modes:</p>
<blockquote>
<div><p>procArgs.processing_mode = mode</p>
<dl class="simple">
<dt>if processingContext.is_capable(mesu, procArgs):</dt><dd><p>print(“processing to mode {}…”.format(mode))
processingContext.set_processing_args(procArgs)
mesu = processingContext.apply(mesu)
mesu.set_name(mode.name)
saveArgs.export_dir = str(Path(outDir) / mode.name)
exporter = cuvis.Export.CubeExporter(saveArgs)
exporter.apply(mesu)</p>
</dd>
<dt>else:</dt><dd><p>print(“Cannot process to {} mode!”.format(mode))</p>
</dd>
</dl>
</div></blockquote>
<p>cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl class="simple">
<dt>if platform.system() == “Windows”:</dt><dd><dl class="simple">
<dt>data_dir = Path(os.getenv(“CUVIS”)).parent / “sdk” / </dt><dd><p>“sample_data” / “set_examples”</p>
</dd>
</dl>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><dl class="simple">
<dt>data_dir = Path(os.getenv(“CUVIS_DATA”)) / </dt><dd><p>“sample_data” / “set_examples”</p>
</dd>
</dl>
</dd>
</dl>
<p># default images
loc_file = data_dir / “set0_single” / “single_raw.cu3s”
loc_dark = data_dir / “set0_single” / “single_dark.cu3s”
loc_white = data_dir / “set0_single” / “single_white.cu3s”</p>
<p>loc_distance = data_dir / “set0_single” / “single_distance.cu3s”</p>
<p># default settings
loc_settings = data_dir / “settings”</p>
<p># default output
loc_output = Path(os.getcwd()) / “EX02_reprocessed”</p>
<dl class="simple">
<dt>print(</dt><dd><p>“Example 02: Reprocess Measurement. Please provide:”)</p>
</dd>
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
<dt>measurementLoc = input(</dt><dd><p>“Measurement file (.cu3s) (default: {}): “.format(loc_file))</p>
</dd>
<dt>if measurementLoc.strip().lower() in [“”, “default”]:</dt><dd><p>measurementLoc = loc_file</p>
</dd>
</dl>
<p>darkLoc = input(“Dark file (.cu3s) (default: {}): “.format(loc_dark))
if darkLoc.strip().lower() in [“”, “default”]:</p>
<blockquote>
<div><p>darkLoc = loc_dark</p>
</div></blockquote>
<p>whiteLoc = input(“White file (.cu3s) (default: {}): “.format(loc_white))
if whiteLoc.strip().lower() in [“”, “default”]:</p>
<blockquote>
<div><p>whiteLoc = loc_white</p>
</div></blockquote>
<dl class="simple">
<dt>distanceLoc = input(</dt><dd><p>“Distance file (.cu3s) (default: {}): “.format(loc_distance))</p>
</dd>
<dt>if distanceLoc.strip().lower() in [“”, “default”]:</dt><dd><p>distanceLoc = loc_distance</p>
</dd>
<dt>outDir = input(</dt><dd><p>“Name of output directory (default: {}): “.format(loc_output))</p>
</dd>
<dt>if outDir.strip().lower() in [“”, “default”]:</dt><dd><p>outDir = loc_output</p>
</dd>
<dt>run_example_reprocessMeasurement(str(userSettingsDir),</dt><dd><p>str(measurementLoc),
str(darkLoc),
str(whiteLoc),
str(distanceLoc),
str(outDir))</p>
</dd>
</dl>
</div></blockquote>
</div></div>
</section>
<section id="exporting-a-measurement">
<h2>Exporting a Measurement<a class="headerlink" href="#exporting-a-measurement" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-2-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-2-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-2-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-2-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-2-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-2-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-2-Qw==" class="sphinx-tabs-panel group-tab" id="panel-2-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 5)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“sessionfile (.cu3s)n”);
printf(“user plugin file (.xml)n”);
printf(“Name of export directoryn”);
fflush(stdout);</p>
<p>return -1;</p>
</div></blockquote>
<p>}
const char* userSettingsDir = argv[1];
const char* sessionLoc = argv[2];
const char* pluginLoc = argv[3];
const char* exportDir = argv[4];</p>
<p>printf(“Example 03 export measurementn”);
printf(“User Settings Dir: “);
printf(userSettingsDir);
printf(”nsessionfile (.cu3s): “);
printf(sessionLoc);
printf(”nuser plugin file (.xml): “);
printf(pluginLoc);
printf(”nExport Dir: “);
printf(exportDir);
fflush(stdout);</p>
<p>CUVIS_SESSION_FILE sess;
CUVIS_MESU mesu;</p>
<p>CUVIS_EXPORTER envi_exporter;
CUVIS_EXPORTER single_tiff_exporter;</p>
<p>CUVIS_EXPORT_TIFF_SETTINGS single_tiff_settings;</p>
<p>CUVIS_EXPORTER multi_tiff_exporter;
CUVIS_EXPORT_TIFF_SETTINGS multi_tiff_settings;</p>
<p>CUVIS_EXPORTER view_exporter;
CUVIS_EXPORT_VIEW_SETTINGS view_settings;</p>
<p>CUVIS_EXPORTER cube_exporter;</p>
<p>char* buffer = 0;
long length;
FILE* f;</p>
<p>printf(”nloading user settings…n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));</p>
</div></blockquote>
<dl class="simple">
<dt>#ifdef _DEBUG</dt><dd><p>CUVIS_CHECK(cuvis_set_log_level(loglevel_debug));</p>
</dd>
<dt>#else</dt><dd><p>CUVIS_CHECK(cuvis_set_log_level(loglevel_info));</p>
</dd>
</dl>
<p>#endif</p>
<blockquote>
<div><dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings_envi = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>char exportDirEnvi[CUVIS_MAXBUF];
strcpy(exportDirEnvi, exportDir);
strcat(exportDirEnvi, “/envi”);
strcpy(general_settings_envi.export_dir, exportDirEnvi);</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings_single = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>char exportDirSingle[CUVIS_MAXBUF];
strcpy(exportDirSingle, exportDir);
strcat(exportDirSingle, “/single”);
strcpy(general_settings_single.export_dir, exportDirSingle);</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings_multi = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>char exportDirMulti[CUVIS_MAXBUF];
strcpy(exportDirMulti, exportDir);
strcat(exportDirMulti, “/multi”);
strcpy(general_settings_multi.export_dir, exportDirMulti);</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings_view = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>char exportDirView[CUVIS_MAXBUF];
strcpy(exportDirView, exportDir);
strcat(exportDirView, “/view”);
strcpy(general_settings_view.export_dir, exportDirView);</p>
<dl class="simple">
<dt>CUVIS_EXPORT_CUBE_SETTINGS cube_settings_session = {</dt><dd><p>0, 1, 0, 1, 1, OperationMode_Software, 1.0, 64, 128, 60000};</p>
</dd>
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings_session = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>char exportDirSession[CUVIS_MAXBUF];
strcpy(exportDirSession, exportDir);
strcat(exportDirSession, “/session”);
strcpy(general_settings_session.export_dir, exportDirSession);</p>
<p>printf(“loading session …n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_load(sessionLoc, &amp;sess));</p>
<p>printf(“loading measurement …n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_get_mesu(</p>
<blockquote>
<div><p>sess, 0, session_item_type_frames_no_gaps, &amp;mesu));</p>
</div></blockquote>
<p>printf(“creating envi exporter …n”);
fflush(stdout);
CUVIS_CHECK(</p>
<blockquote>
<div><p>cuvis_exporter_create_envi(&amp;envi_exporter, general_settings_envi));</p>
</div></blockquote>
<p>printf(” done.n”);
fflush(stdout);</p>
<p>printf(“creating single tiff exporter …n”);
fflush(stdout);</p>
<p>single_tiff_settings.compression_mode = tiff_compression_mode_None;
single_tiff_settings.format = tiff_format_Single;
CUVIS_CHECK(cuvis_exporter_create_tiff(</p>
<blockquote>
<div><p>&amp;single_tiff_exporter, general_settings_single, single_tiff_settings));</p>
</div></blockquote>
<p>printf(” done.n”);
fflush(stdout);</p>
<p>printf(“creating multi tiff exporter …n”);
fflush(stdout);</p>
<p>multi_tiff_settings.compression_mode = tiff_compression_mode_None;
multi_tiff_settings.format = tiff_format_MultiChannel;
CUVIS_CHECK(cuvis_exporter_create_tiff(</p>
<blockquote>
<div><p>&amp;multi_tiff_exporter, general_settings_multi, multi_tiff_settings));</p>
</div></blockquote>
<p>printf(” done.n”);
fflush(stdout);</p>
<p>printf(“creating view exporter …n”);
printf(“loading plugin …n”);
fflush(stdout);</p>
<p>f = fopen(pluginLoc, “rb”);</p>
<p>if (f)
{</p>
<blockquote>
<div><p>fseek(f, 0, SEEK_END);
length = ftell(f);
fseek(f, 0, SEEK_SET);
buffer = malloc(length);
if (buffer)
{</p>
<blockquote>
<div><p>fread(buffer, 1, length, f);</p>
</div></blockquote>
<p>}
fclose(f);</p>
</div></blockquote>
<p>}
if (!buffer)
{</p>
<blockquote>
<div><p>printf(“failed to load plugin filen”);
fflush(stdout);</p>
<p>return 0;</p>
</div></blockquote>
<p>}</p>
<p>view_settings.userplugin = buffer;
CUVIS_CHECK(cuvis_exporter_create_view(</p>
<blockquote>
<div><p>&amp;view_exporter, general_settings_view, view_settings));</p>
</div></blockquote>
<p>printf(” done.n”);
fflush(stdout);</p>
<p>printf(“creating cube exporter (session) …n”);
fflush(stdout);
CUVIS_CHECK(cuvis_exporter_create_cube(</p>
<blockquote>
<div><p>&amp;cube_exporter, general_settings_session, cube_settings_session));</p>
</div></blockquote>
<p>printf(” done.n”);
fflush(stdout);</p>
<p>printf(“export envi…”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_exporter_apply(envi_exporter, mesu));
printf(” done.n”);
fflush(stdout);</p>
<p>printf(“export single tiff…”);
fflush(stdout);
CUVIS_CHECK(cuvis_exporter_apply(single_tiff_exporter, mesu));
printf(” done.n”);
fflush(stdout);</p>
<p>printf(“export multi tiff…”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_exporter_apply(multi_tiff_exporter, mesu));
printf(” done.n”);
fflush(stdout);</p>
<p>printf(“export view…”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_exporter_apply(view_exporter, mesu));
printf(“done.n”);
fflush(stdout);</p>
<p>printf(“export cube (session)…”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_exporter_apply(cube_exporter, mesu));
printf(“done.n”);
fflush(stdout);</p>
<p>cuvis_measurement_free(&amp;mesu);
cuvis_session_file_free(&amp;sess);
cuvis_exporter_free(&amp;envi_exporter);
cuvis_exporter_free(&amp;single_tiff_exporter);
cuvis_exporter_free(&amp;multi_tiff_exporter);
cuvis_exporter_free(&amp;view_exporter);
cuvis_exporter_free(&amp;cube_exporter);
cuvis_shutdown();</p>
<p>free(buffer);
printf(“finished.n”);
fflush(stdout);</p>
<p>return 0;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-2-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-2-Qysr" name="Qysr" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 5)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; std::endl &lt;&lt; “Too few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile (.cu3s)” &lt;&lt; std::endl;
std::cout &lt;&lt; “user plugin file (.xml)” &lt;&lt; std::endl;
std::cout &lt;&lt; “Name of export directory” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}
char* const userSettingsDir = argv[1];
char* const sessionLoc = argv[2];
char* const pluginLoc = argv[3];
char* const exportDir = argv[4];</p>
<p>std::cout &lt;&lt; “Example 03 export measurement” &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile (.cu3s): “ &lt;&lt; sessionLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “user plugin file (.xml): “ &lt;&lt; pluginLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “Export Dir: “ &lt;&lt; exportDir &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading settings… “ &lt;&lt; std::endl;
cuvis::General::init(userSettingsDir);
cuvis::General::set_log_level(loglevel_info);</p>
<p>std::cout &lt;&lt; “loading session… “ &lt;&lt; std::endl;
cuvis::SessionFile sess(sessionLoc);</p>
<p>std::cout &lt;&lt; “loading measurement… “ &lt;&lt; std::endl;
auto optmesu = sess.get_mesu(0);
assert(optmesu.has_value());
cuvis::Measurement mesu = optmesu.value();</p>
<p>assert(mesu.get_meta()-&gt;processing_mode != cuvis::processing_mode_t::Preview);</p>
<dl class="simple">
<dt>{</dt><dd><p>std::cout &lt;&lt; “Export to Envi” &lt;&lt; std::endl;
cuvis::EnviArgs args;
char exportDirEnvi[CUVIS_MAXBUF];
strcpy(exportDirEnvi, exportDir);
strcat(exportDirEnvi, “/envi”);
args.export_dir = exportDirEnvi;
cuvis::EnviExporter exporter(args);
exporter.apply(mesu);</p>
</dd>
</dl>
<blockquote>
<div><p>std::cout &lt;&lt; “Export to Multi-Channel Tiff” &lt;&lt; std::endl;
cuvis::TiffArgs args;
char exportDirMulti[CUVIS_MAXBUF];
strcpy(exportDirMulti, exportDir);
strcat(exportDirMulti, “/multi”);
args.export_dir = exportDirMulti;
args.format = cuvis::tiff_format_t::tiff_format_MultiChannel;
cuvis::TiffExporter exporter(args);
exporter.apply(mesu);</p>
</div></blockquote>
<blockquote>
<div><p>std::cout &lt;&lt; “Export to separate Tiffs” &lt;&lt; std::endl;
cuvis::TiffArgs args;
char exportDirSingle[CUVIS_MAXBUF];
strcpy(exportDirSingle, exportDir);
strcat(exportDirSingle, “/single”);
args.export_dir = exportDirSingle;
args.format = cuvis::tiff_format_t::tiff_format_Single;
cuvis::TiffExporter exporter(args);
exporter.apply(mesu);</p>
</div></blockquote>
<blockquote>
<div><p>std::cout &lt;&lt; “Export View to file” &lt;&lt; std::endl;
cuvis::ViewArgs args;
char exportDirView[CUVIS_MAXBUF];
strcpy(exportDirView, exportDir);
strcat(exportDirView, “/view”);
args.export_dir = exportDirView;</p>
<p>std::cout &lt;&lt; “Load plugin” &lt;&lt; std::endl;
std::ifstream file(pluginLoc);
args.userplugin = std::string(</p>
<blockquote>
<div><p>(std::istreambuf_iterator&lt;char&gt;(file)),
std::istreambuf_iterator&lt;char&gt;());</p>
</div></blockquote>
<p>cuvis::ViewExporter exporter(args);
exporter.apply(mesu);</p>
</div></blockquote>
<blockquote>
<div><p>std::cout &lt;&lt; “Export to sessionfile” &lt;&lt; std::endl;
char exportDirView[CUVIS_MAXBUF];
strcpy(exportDirView, exportDir);
strcat(exportDirView, “/session”);</p>
<p>cuvis::SaveArgs saveArgs;
saveArgs.export_dir = exportDirView;
saveArgs.allow_overwrite = true;
saveArgs.allow_session_file = true;</p>
<p>cuvis::CubeExporter exporter(saveArgs);
exporter.apply(mesu);</p>
</div></blockquote>
<p>}
cuvis::General::shutdown();
std::cout &lt;&lt; “finished.” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-2-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-2-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
from pathlib import Path</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_exportMeasurement(userSettingsDir,</dt><dd><blockquote>
<div><p>measurementLoc,
pluginLoc,
exportDir):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<p>print(“loading session file…”)
session = cuvis.SessionFile(measurementLoc)
mesu = session[0]
assert mesu._handle</p>
<dl class="simple">
<dt>assert mesu.processing_mode != cuvis.ProcessingMode.Preview, “Wrong processing mode: {}”.format(</dt><dd><p>mesu.processing_mode.name)</p>
</dd>
</dl>
<p>print(“Export to Envi…”)
envi_settings = cuvis.EnviExportSettings(</p>
<blockquote>
<div><p>export_dir=os.path.join(exportDir, “envi”))</p>
</div></blockquote>
<p>enviExporter = cuvis.EnviExporter(envi_settings)
enviExporter.apply(mesu)</p>
<p>print(“Export to Multi-Channel Tiff…”)
multi_tiff_settings = cuvis.TiffExportSettings(</p>
<blockquote>
<div><p>export_dir=os.path.join(exportDir, “multi”), format=cuvis.TiffFormat.MultiChannel)</p>
</div></blockquote>
<p>multiTiffExporter = cuvis.TiffExporter(multi_tiff_settings)
multiTiffExporter.apply(mesu)</p>
<p>print(“Export to separate Tiffs…”)
single_tiff_settings = cuvis.TiffExportSettings(</p>
<blockquote>
<div><p>export_dir=os.path.join(exportDir, “single”), format=cuvis.TiffFormat.Single)</p>
</div></blockquote>
<p>singleTiffExporter = cuvis.TiffExporter(single_tiff_settings)
singleTiffExporter.apply(mesu)</p>
<p>print(“Export View to file…”)</p>
<p>print(“load plugin…”)
with open(pluginLoc) as f:</p>
<blockquote>
<div><p>userpluginCai = f.readlines()</p>
</div></blockquote>
<p>userpluginCai = “”.join(userpluginCai)</p>
<dl class="simple">
<dt>view_export_settings = cuvis.ViewExportSettings(</dt><dd><p>export_dir=os.path.join(exportDir, “view”), userplugin=userpluginCai)</p>
</dd>
</dl>
<p># also view_export_settings = cuvis.ViewExportSettings(ExportDir=os.path.join(exportDir, “view”),
# Userplugin=pluginLoc) works!
viewExporter = cuvis.ViewExporter(view_export_settings)
viewExporter.apply(mesu)</p>
<p>cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl>
<dt>if platform.system() == “Windows”:</dt><dd><p>lib_dir = Path(os.getenv(“CUVIS”))
data_dir = lib_dir.parent / “sdk” / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
<p>plugin_dir = lib_dir.parent / “user” / “plugin”</p>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><p>lib_dir = Path(os.getenv(“CUVIS_DATA”))
data_dir = lib_dir / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
<p>plugin_dir = lib_dir / “user” / “plugin”</p>
</dd>
</dl>
<p># default images
loc_file = data_dir / “set0_single” / “single.cu3s”
loc_plugin = plugin_dir / “ref” / “cai.xml”</p>
<p># default settings
loc_settings = data_dir / “settings”</p>
<p># default output
loc_output = Path(os.getcwd()) / “EX03_export”</p>
<p>print(“Example 03: Export Measurement. Please provide:”)</p>
<dl class="simple">
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
<dt>measurementLoc = input(</dt><dd><p>“Measurement file (.cu3) (default: {}): “.format(loc_file))</p>
</dd>
<dt>if measurementLoc.strip().lower() in [“”, “default”]:</dt><dd><p>measurementLoc = loc_file</p>
</dd>
<dt>pluginLoc = input(</dt><dd><p>“User plugin file (.xml) (default: {}): “.format(loc_plugin))</p>
</dd>
<dt>if pluginLoc.strip().lower() in [“”, “default”]:</dt><dd><p>pluginLoc = loc_plugin</p>
</dd>
<dt>exportDir = input(</dt><dd><p>“Name of export directory (default: {}): “.format(loc_output))</p>
</dd>
<dt>if exportDir.strip().lower() in [“”, “default”]:</dt><dd><p>exportDir = loc_output</p>
</dd>
<dt>run_example_exportMeasurement(str(userSettingsDir), str(measurementLoc), str(pluginLoc),</dt><dd><p>str(exportDir))</p>
</dd>
</dl>
</div></blockquote>
</div></div>
</section>
<section id="changing-the-distance-of-a-measurement">
<h2>Changing the Distance of a Measurement<a class="headerlink" href="#changing-the-distance-of-a-measurement" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-3-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-3-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-3-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-3-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-3-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-3-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-3-Qw==" class="sphinx-tabs-panel group-tab" id="panel-3-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 5)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“sessionfile (.cu3s)n”);
printf(“new distancen”);
printf(“Name of export directoryn”);
fflush(stdout);</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const sessionLoc = argv[2];
char* const distanceString = argv[3];
char* const exportDir = argv[4];</p>
<p>int distance = atoi(distanceString); //in mm</p>
<p>printf(“Example 04 change distance cpp n”);
printf(userSettingsDir);
printf(”nsessionfile (.cu3s): “);
printf(sessionLoc);
printf(”nNew Distance: %dn”, distance);
printf(“Export Dir: “);
printf(exportDir);
fflush(stdout);</p>
<p>CUVIS_SESSION_FILE sess;</p>
<p>CUVIS_MESU mesu;
CUVIS_MESU_METADATA mesu_data;</p>
<p>CUVIS_PROC_CONT procCont;</p>
<p>CUVIS_INT is_capable;</p>
<p>printf(”nloading settings… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));</p>
</div></blockquote>
<dl class="simple">
<dt>#ifdef _DEBUG</dt><dd><p>CUVIS_CHECK(cuvis_set_log_level(loglevel_debug));</p>
</dd>
<dt>#else</dt><dd><p>CUVIS_CHECK(cuvis_set_log_level(loglevel_info));</p>
</dd>
</dl>
<p>#endif</p>
<blockquote>
<div><p>printf(”nloading session… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_load(sessionLoc, &amp;sess));</p>
<p>printf(”nloading measurement… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_get_mesu(</p>
<blockquote>
<div><p>sess, 0, session_item_type_frames_no_gaps, &amp;mesu));</p>
</div></blockquote>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>printf(“Load calibration and processing context…”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_create_from_session_file(sess, &amp;procCont));
printf(” done. n”);
fflush(stdout);</p>
<p>printf(“prepare saving of measurements… n”);
fflush(stdout);
CUVIS_EXPORTER cube_exporter;</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>strcpy(general_settings.export_dir, exportDir);</p>
<p>CUVIS_EXPORT_CUBE_SETTINGS cube_settings;
cube_settings.allow_fragmentation = 0;
cube_settings.allow_overwrite = 1;
cube_settings.allow_session_file = 1;</p>
<p>cuvis_exporter_create_cube(&amp;cube_exporter, general_settings, cube_settings);</p>
<p>printf(“Set distance …”);
fflush(stdout);
//CUVIS_CHECK(cuvis_proc_cont_calc_distance(procCont, distance)); // throws error on pan image
cuvis_proc_cont_calc_distance(procCont, distance);
printf(” done. n”);
fflush(stdout);</p>
<p>CUVIS_PROC_ARGS args;
args.processing_mode = Cube_Raw;</p>
<p>CUVIS_CHECK(cuvis_proc_cont_is_capable(procCont, mesu, args, &amp;is_capable));</p>
<p>if (1 == is_capable)
{</p>
<blockquote>
<div><p>printf(“reprocess measurement to Cube_Raw with custom distance mode…”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, args));
CUVIS_CHECK(cuvis_proc_cont_apply(procCont, mesu));
printf(” done. n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“data 1 %s %.2f ms mode=%d flags=%dn”,
mesu_data.name,
mesu_data.integration_time,
mesu_data.processing_mode,
mesu_data.measurement_flags);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>cuvis_exporter_apply(cube_exporter, mesu);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“Cannot process to Cube_Raw mode.n”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>cuvis_exporter_free(&amp;cube_exporter);
cuvis_proc_cont_free(&amp;procCont);
cuvis_measurement_free(&amp;mesu);
cuvis_shutdown();
printf(“finished.”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-3-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-3-Qysr" name="Qysr" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;iostream&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 5)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; std::endl &lt;&lt; “Too few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile (.cu3s)” &lt;&lt; std::endl;
std::cout &lt;&lt; “new distance in mm” &lt;&lt; std::endl;
std::cout &lt;&lt; “Name of export directory” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const sessionLoc = argv[2];
char* const distanceString = argv[3];
char* const exportDir = argv[4];</p>
<p>int distance = std::stoi(distanceString);</p>
<p>std::cout &lt;&lt; “Example 04 change distance cpp “ &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile (.cu3s): “ &lt;&lt; sessionLoc &lt;&lt; std::endl;
std::cout &lt;&lt; “New Distance in mm: “ &lt;&lt; distance &lt;&lt; std::endl;
std::cout &lt;&lt; “Export Dir: “ &lt;&lt; exportDir &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading settings… “ &lt;&lt; std::endl;
cuvis::General::init(userSettingsDir);
cuvis::General::set_log_level(loglevel_info);</p>
<p>std::cout &lt;&lt; “loading session… “ &lt;&lt; std::endl;
cuvis::SessionFile sess(sessionLoc);</p>
<p>std::cout &lt;&lt; “loading measurement… “ &lt;&lt; std::endl;
auto optmesu = sess.get_mesu(0);
assert(optmesu.has_value());
cuvis::Measurement mesu = optmesu.value();</p>
<dl class="simple">
<dt>std::cout &lt;&lt; “Data 1” &lt;&lt; mesu.get_meta()-&gt;name &lt;&lt; “ “</dt><dd><p>&lt;&lt; “t=” &lt;&lt; mesu.get_meta()-&gt;integration_time &lt;&lt; “ ms ”
&lt;&lt; “mode=” &lt;&lt; mesu.get_meta()-&gt;processing_mode &lt;&lt; “ “ &lt;&lt; std::endl;</p>
</dd>
</dl>
<p>std::cout &lt;&lt; “Loading Calibration and processing context…” &lt;&lt; std::endl;
cuvis::ProcessingContext proc(sess);</p>
<p>cuvis::SaveArgs saveArgs;
saveArgs.allow_overwrite = true;
saveArgs.export_dir = exportDir;
saveArgs.allow_session_file = true;</p>
<p>cuvis::CubeExporter exporter(saveArgs);</p>
<p>std::cout &lt;&lt; “setting distance…” &lt;&lt; std::endl;
proc.calc_distance(distance);</p>
<p>cuvis::ProcessingArgs procArgs = proc.get_processingArgs();
procArgs.processing_mode = cuvis::processing_mode_t::Cube_Raw;</p>
<p>assert(proc.is_capable(mesu, procArgs));</p>
<p>std::cout &lt;&lt; “changing distance…” &lt;&lt; std::endl;
proc.apply(mesu);
std::cout &lt;&lt; “saving…” &lt;&lt; std::endl;
exporter.apply(mesu);
cuvis::General::shutdown();
std::cout &lt;&lt; “finished.” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-3-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-3-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
from pathlib import Path</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_changeDistance(userSettingsDir,</dt><dd><blockquote>
<div><p>measurementLoc,
distance,
exportDir):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<p>print(“loading session file…”)
session = cuvis.SessionFile(measurementLoc)
mesu = session[0]
assert mesu._handle</p>
<dl class="simple">
<dt>print(“Data 1 {} t={}ms mode={}”.format(mesu.name,</dt><dd><p>mesu.integration_time,
mesu.processing_mode.name,
))</p>
</dd>
</dl>
<p>print(“loading calibration and processing context (factory)…”)
processingContext = cuvis.ProcessingContext(session)</p>
<p>print(“setting distance…”)
processingContext.calc_distance(distance)</p>
<p>processingContext.processing_mode = cuvis.ProcessingMode.Raw</p>
<p>saveArgs = cuvis.SaveArgs(export_dir=exportDir, allow_overwrite=True)</p>
<dl class="simple">
<dt>assert processingContext.is_capable(mesu,</dt><dd><p>processingContext.get_processing_args())</p>
</dd>
</dl>
<p>print(“changing distance…”)
print(“original distance…”)
print(mesu.distance)
processingContext.apply(mesu)
print(“new distance…”)
print(mesu.distance)
print(“saving…”)
mesu.save(saveArgs)</p>
<p>cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl class="simple">
<dt>if platform.system() == “Windows”:</dt><dd><dl class="simple">
<dt>data_dir = Path(os.getenv(“CUVIS”)).parent / “sdk” / </dt><dd><p>“sample_data” / “set_examples”</p>
</dd>
</dl>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><dl class="simple">
<dt>data_dir = Path(os.getenv(“CUVIS_DATA”)) / </dt><dd><p>“sample_data” / “set_examples”</p>
</dd>
</dl>
</dd>
</dl>
<p># default image
loc_file = data_dir / “set0_single” / “single.cu3s”
# default settings
loc_settings = data_dir / “settings”</p>
<p>loc_distance = int(1000)</p>
<p># default output
loc_output = Path(os.getcwd()) / “EX04_distance_changed”</p>
<p>print(“Example 04: Change distance. Please provide:”)</p>
<dl class="simple">
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
<dt>measurementLoc = input(</dt><dd><p>“Measurement file (.cu3) (default: {}): “.format(loc_file))</p>
</dd>
<dt>if measurementLoc.strip().lower() in [“”, “default”]:</dt><dd><p>measurementLoc = loc_file</p>
</dd>
</dl>
<p>distance = input(“New distance in mm (default: {}): “.format(loc_distance))
if distance.strip().lower() in [“”, “default”]:</p>
<blockquote>
<div><p>distance = loc_distance</p>
</div></blockquote>
<p>distance = int(distance)</p>
<dl class="simple">
<dt>exportDir = input(</dt><dd><p>“Name of export directory (default: {}): “.format(loc_output))</p>
</dd>
<dt>if exportDir.strip().lower() in [“”, “default”]:</dt><dd><p>exportDir = loc_output</p>
</dd>
<dt>run_example_changeDistance(str(userSettingsDir), str(measurementLoc),</dt><dd><p>distance, str(exportDir))</p>
</dd>
</dl>
</div></blockquote>
</div></div>
</section>
<section id="recording-single-measurements">
<h2>Recording single Measurements<a class="headerlink" href="#recording-single-measurements" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-4-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-4-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-4-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-4-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-4-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-4-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-4-Qw==" class="sphinx-tabs-panel group-tab" id="panel-4-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;</p>
<dl class="simple">
<dt>#ifdef WIN32</dt><dd><p>#include &lt;Windows.h&gt;</p>
</dd>
<dt>#else</dt><dd><p>#include &lt;unistd.h&gt;</p>
</dd>
</dl>
<p>#endif</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 6)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“factory directoryn”);
printf(“path of recording directoryn”);
printf(“exposure time in msn”);
printf(“number of imagesn”);
return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const factoryDir = argv[2];
char* const recDir = argv[3];
char* const exposureString = argv[4]; //in ms
char* const nrImagesString = argv[5];</p>
<p>int exposure_ms = atoi(exposureString);
int nrImages = atoi(nrImagesString);</p>
<p>printf(“Example 05 record single imagen”);
printf(“User Settings directory: “);
printf(userSettingsDir);
printf(”nFactory directory: “);
printf(factoryDir);
printf(”nRecording directory: “);
printf(recDir);
printf(”nExposure in ms: %dn”, exposure_ms);
printf(“Number of images: %dn”, nrImages);</p>
<p>CUVIS_CALIB calib;
CUVIS_ACQ_CONT acqCont;
CUVIS_PROC_CONT procCont;</p>
<p>printf(“load user settings…n”);
CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));
cuvis_set_log_level(loglevel_info);</p>
<p>printf(“load calibration…n”);
CUVIS_CHECK(cuvis_calib_create_from_path(factoryDir, &amp;calib));</p>
<p>printf(“initialize processing context…n”);
CUVIS_CHECK(cuvis_proc_cont_create_from_calib(calib, &amp;procCont));</p>
<p>printf(“initialize acquisition context…n”);
CUVIS_CHECK(cuvis_acq_cont_create_from_calib(calib, &amp;acqCont));</p>
<p>printf(“initialize measurement exporter…n”);
CUVIS_EXPORTER cube_exporter;</p>
<p>// Export settings: General processing of measurements
CUVIS_EXPORT_GENERAL_SETTINGS general_settings = {</p>
<blockquote>
<div><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</div></blockquote>
<p>strcpy(general_settings.export_dir, recDir);</p>
<p>// Cube exporter specific settings
CUVIS_EXPORT_CUBE_SETTINGS cube_settings;
cube_settings.allow_fragmentation = 0;
cube_settings.allow_overwrite = 1;
cube_settings.allow_session_file = 1;
cube_settings.allow_info_file = 1;
cube_settings.hard_limit = 4;
cube_settings.soft_limit = 2;</p>
<p>// Settings for worker (processing pipeline)
CUVIS_WORKER_SETTINGS worker_settings;
worker_settings.can_drop_results = 0;
worker_settings.can_skip_measurements = 0;
worker_settings.can_skip_supplementary_steps = 0;
worker_settings.input_queue_size = 10;
worker_settings.output_queue_size = 5;
worker_settings.mandatory_queue_size = 2;
worker_settings.supplementary_queue_size = 2;</p>
<p>cuvis_exporter_create_cube(&amp;cube_exporter, general_settings, cube_settings);</p>
<p>printf(“initialize processing pipeline worker…n”);
CUVIS_WORKER worker;
cuvis_worker_create(&amp;worker, worker_settings);</p>
<p>CUVIS_PROC_ARGS procArgs;
procArgs.allow_recalib = 0;
procArgs.processing_mode = Cube_Raw;</p>
<p>printf(“waiting for camera to become online…n”);
while (1)
{</p>
<blockquote>
<div><p>CUVIS_HARDWARE_STATE state;
cuvis_acq_cont_get_state(acqCont, &amp;state);</p>
<p>if (state == hardware_state_online)
{</p>
<blockquote>
<div><p>printf(”ncamera onlinen”);
break;</p>
</div></blockquote>
<p>}
if (state == hardware_state_partially_online)
{</p>
<blockquote>
<div><p>printf(”ncamera partially onlinen”);
break;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>#ifdef WIN32</dt><dd><p>Sleep(1000);</p>
</dd>
<dt>#else</dt><dd><p>usleep(1000000);</p>
</dd>
<dt>#endif</dt><dd><blockquote>
<div><p>printf(“.”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>printf(“camera components details:n”);
CUVIS_INT compCount;
CUVIS_CHECK(cuvis_acq_cont_get_component_count(acqCont, &amp;compCount));
for (int compIdx = 0; compIdx &lt; compCount; compIdx++)
{</p>
<blockquote>
<div><p>CUVIS_INT online;
CUVIS_COMPONENT_INFO cinfo;</p>
<p>CUVIS_CHECK(cuvis_acq_cont_get_component_info(acqCont, compIdx, &amp;cinfo));
CUVIS_CHECK(cuvis_comp_online_get(acqCont, compIdx, &amp;online));
printf(” - component ‘%s’ is “, cinfo.displayname);
if (online != 0)
{</p>
<blockquote>
<div><p>printf(“onlinen”);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“offlinen”);</p>
</div></blockquote>
<p>}
printf(” – info:        %sn”, cinfo.sensorinfo);
printf(” – use:         %sn”, cinfo.userfield);
printf(” – pixelformat: %sn”, cinfo.pixelformat);</p>
</div></blockquote>
<p>}</p>
<p>printf(“configuring camera components…n”);
// Configure exposure / integration time and software trigger
CUVIS_CHECK(cuvis_acq_cont_integration_time_set(acqCont, exposure_ms));
CUVIS_CHECK(cuvis_acq_cont_operation_mode_set(acqCont, OperationMode_Software));</p>
<p>// Assign contexts to worker
CUVIS_CHECK(cuvis_worker_set_acq_cont(worker, acqCont));
CUVIS_CHECK(cuvis_worker_set_proc_cont(worker, procCont));
CUVIS_CHECK(cuvis_worker_set_exporter(worker, cube_exporter));</p>
<p>printf(“start recording nown”);
CUVIS_CHECK(cuvis_worker_start(worker));</p>
<p>for (int k = 0; k &lt; nrImages; k++)
{</p>
<blockquote>
<div><p>printf(“trigger image nr. %d/%dn”, k + 1, nrImages);
CUVIS_CHECK(cuvis_acq_cont_capture_async(acqCont, NULL));</p>
<p>printf(“waiting for processing…n”);
CUVIS_CHECK(cuvis_worker_get_next_result(worker, NULL, NULL, exposure_ms + 2000));</p>
</div></blockquote>
<p>}
CUVIS_CHECK(cuvis_worker_stop(worker));
printf(“done. cleaning up…n”);</p>
<p>cuvis_exporter_free(&amp;cube_exporter);
cuvis_proc_cont_free(&amp;procCont);
cuvis_acq_cont_free(&amp;acqCont);
cuvis_calib_free(&amp;calib);
cuvis_worker_free(&amp;worker);</p>
<p>cuvis_shutdown();
printf(“finished.n”);</p>
</dd>
</dl>
<p>}</p>
</div><div aria-labelledby="tab-4-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-4-Qysr" name="Qysr" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;iostream&gt;</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 6)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; std::endl &lt;&lt; “Too few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “factory directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “name of recording directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “exposure time in ms” &lt;&lt; std::endl;
std::cout &lt;&lt; “number of images” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const factoryDir = argv[2];
char* const recDir = argv[3];
char* const exposureString = argv[4];
char* const nrImagesString = argv[5];</p>
<p>int exposure_ms = std::stoi(exposureString);
int nrImages = std::stoi(nrImagesString);</p>
<p>std::cout &lt;&lt; “Example 05 record single image “ &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Factory Dir: “ &lt;&lt; factoryDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Recording Dir: “ &lt;&lt; recDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Exposure in ms: “ &lt;&lt; exposure_ms &lt;&lt; std::endl;
std::cout &lt;&lt; “Number of Images: “ &lt;&lt; nrImages &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading user settings…” &lt;&lt; std::endl;
cuvis::General::init(userSettingsDir);
cuvis::General::set_log_level(loglevel_info);</p>
<p>std::cout &lt;&lt; “Loading Calibration and processing context…” &lt;&lt; std::endl;
cuvis::Calibration calib(factoryDir);
cuvis::ProcessingContext proc(calib);
cuvis::AcquisitionContext acq(calib);</p>
<p>cuvis::SaveArgs saveArgs;
saveArgs.allow_overwrite = true;
saveArgs.export_dir = recDir;
saveArgs.allow_session_file = true;</p>
<p>cuvis::CubeExporter exporter(saveArgs);</p>
<p>while (cuvis::hardware_state_t::hardware_state_offline == acq.get_state())
{</p>
<blockquote>
<div><p>std::this_thread::sleep_for(std::chrono::seconds(1));</p>
</div></blockquote>
<p>}</p>
<p>std::cout &lt;&lt; “Camera is online” &lt;&lt; std::endl;
acq.set_operation_mode(cuvis::operation_mode_t::OperationMode_Software).get();
acq.set_integration_time(exposure_ms).get();</p>
<p>std::cout &lt;&lt; “Start recording now” &lt;&lt; std::endl;
for (int k = 0; k &lt; nrImages; k++)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “Record image #” &lt;&lt; k &lt;&lt; “… (async) “;
auto async_mesu = acq.capture();
auto mesu_res = async_mesu.get(std::chrono::milliseconds(500));
if (mesu_res.first == cuvis::async_result_t::done &amp;&amp;</p>
<blockquote>
<div><p>mesu_res.second.has_value())</p>
</div></blockquote>
<dl>
<dt>{</dt><dd><p>auto&amp; mesu = mesu_res.second.value();</p>
<p>proc.apply(mesu);
exporter.apply(mesu);</p>
<p>std::cout &lt;&lt; “done” &lt;&lt; std::endl;</p>
</dd>
</dl>
<p>}
else
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “failed” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>//uncomment for recording in queue mode
/*
for (int k = 0; k &lt; nrImages; k++)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “Record image #” &lt;&lt; k &lt;&lt; “… (queue)”;
acq.capture_queue();
auto mesu = acq.get_next_measurement(std::chrono::milliseconds(500));
if (mesu)
{</p>
<blockquote>
<div><p>proc.apply(mesu.value());
exporter.apply(mesu.value());
std::cout &lt;&lt; “done” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; “failed” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}
std::cout &lt;&lt; “done” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}
<a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
<p>cuvis::General::shutdown();
std::cout &lt;&lt; “finished.” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-4-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-4-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
import time
from datetime import timedelta
from pathlib import Path</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_recordSingleImage(</dt><dd><blockquote>
<div><p>userSettingsDir,
factoryDir,
recDir,
exposure,
nrImgs):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<dl class="simple">
<dt>print(</dt><dd><p>“loading calibration, processing and acquisition context (factory)…”)</p>
</dd>
</dl>
<p>calibration = cuvis.Calibration(factoryDir)
processingContext = cuvis.ProcessingContext(calibration)
acquisitionContext = cuvis.AcquisitionContext(calibration)</p>
<dl class="simple">
<dt>saveArgs = cuvis.SaveArgs(export_dir=recDir, allow_overwrite=True,</dt><dd><p>allow_session_file=True)</p>
</dd>
</dl>
<p>cubeExporter = cuvis.CubeExporter(saveArgs)</p>
<dl class="simple">
<dt>while acquisitionContext.state == cuvis.HardwareState.Offline:</dt><dd><p>print(“.”, end=””)
time.sleep(1)</p>
</dd>
</dl>
<p>print(”n”)</p>
<p>print(“Camera is online”)
acquisitionContext.operation_mode = cuvis.OperationMode.Software
acquisitionContext.integration_time = exposure</p>
<p>print(“Start recoding now”)
for i in range(nrImgs):</p>
<blockquote>
<div><p>print(“Record image #{}/{} … (async)”.format(i + 1, nrImgs))
am = acquisitionContext.capture()
mesu, res = am.get(timedelta(milliseconds=500))
if mesu is not None:</p>
<blockquote>
<div><p>processingContext.apply(mesu)
cubeExporter.apply(mesu)</p>
<p>print(“done”)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>print(“failed”)</p>
</dd>
</dl>
</div></blockquote>
<p>cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl>
<dt>if platform.system() == “Windows”:</dt><dd><p>lib_dir = Path(os.getenv(“CUVIS”))
data_dir = lib_dir.parent / “sdk” / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><p>lib_dir = os.getenv(“CUVIS_DATA”)
data_dir = lib_dir / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
</dd>
</dl>
<p># default factory
loc_factory = lib_dir.parent / “factory”
# default settings
loc_settings = data_dir / “settings”</p>
<p># default output
loc_output = Path(os.getcwd()) / “EX05_images”</p>
<p># parameters
loc_exptime = 100  # in msw
loc_nimgs = 10</p>
<p>print(“Example 05: Record single image. Please provide:”)</p>
<dl class="simple">
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
</dl>
<p>factoryDir = input(“Factory directory (default: {}): “.format(loc_factory))
if factoryDir.strip().lower() in [“”, “default”]:</p>
<blockquote>
<div><p>factoryDir = loc_factory</p>
</div></blockquote>
<dl class="simple">
<dt>recDir = input(</dt><dd><p>“Name of recording directory (default: {}): “.format(loc_output))</p>
</dd>
<dt>if recDir.strip().lower() in [“”, “default”]:</dt><dd><p>recDir = loc_output</p>
</dd>
<dt>exposure = input(</dt><dd><p>“Exposure/Integration time in ms (default: {}): “.format(loc_exptime))</p>
</dd>
<dt>if exposure.strip().lower() in [“”, “default”]:</dt><dd><p>exposure = loc_exptime</p>
</dd>
</dl>
<p>exposure = int(exposure)</p>
<p>nrImgs = input(“Number of Images (default: {}): “.format(loc_nimgs))
if nrImgs.strip().lower() in [“”, “default”]:</p>
<blockquote>
<div><p>nrImgs = loc_nimgs</p>
</div></blockquote>
<p>nrImgs = int(nrImgs)</p>
<dl class="simple">
<dt>run_example_recordSingleImage(str(userSettingsDir), str(factoryDir), str(recDir), exposure,</dt><dd><p>nrImgs)</p>
</dd>
</dl>
</div></blockquote>
</div></div>
</section>
<section id="recording-a-video">
<h2>Recording a video<a class="headerlink" href="#recording-a-video" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-5-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-5-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-5-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-5-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-5-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-5-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-5-Qw==" class="sphinx-tabs-panel group-tab" id="panel-5-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;signal.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;</p>
<dl class="simple">
<dt>#ifdef WIN32</dt><dd><p>#include &lt;Windows.h&gt;</p>
</dd>
<dt>#else</dt><dd><p>#include &lt;unistd.h&gt;</p>
</dd>
</dl>
<p>#endif</p>
<p>int keepRunning = 1;</p>
<p>void signal_handler(int sig)
{</p>
<blockquote>
<div><p>printf(”nsignal received. Stopping acquisiton…n”);
fflush(stdout);
(void)sig;
keepRunning = 0;</p>
</div></blockquote>
<p>}</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 7)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“factory directoryn”);
printf(“name of recording directoryn”);
printf(“exposure time in msn”);
printf(“auto exposure [1/0]n”);
printf(“target fpsn”);
fflush(stdout);</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const factoryDir = argv[2];
char* const recDir = argv[3];
char* const exposureString = argv[4];
char* const autoExpString = argv[5];
char* const fpsString = argv[6];</p>
<p>int exposure_ms = atoi(exposureString); //in ms
bool autoExp = false;
if (atoi(autoExpString) == 1)
{</p>
<blockquote>
<div><p>autoExp = true;</p>
</div></blockquote>
<p>}
double fps = atof(fpsString);</p>
<p>printf(“Example 06 video”);
printf(”nUser Settings Dir: “);
printf(userSettingsDir);
printf(”nFactory Dir: “);
printf(factoryDir);
printf(”nRecording Dir: “);
printf(recDir);
printf(”nExposure in ms: %dn”, exposure_ms);
printf(“Auto Exposure: %dn”, autoExp);
printf(“Target FPS: %4.2fn”, fps);
fflush(stdout);</p>
<p>CUVIS_CALIB calib;
CUVIS_ACQ_CONT acqCont;
CUVIS_PROC_CONT procCont;</p>
<p>printf(“loading user settings…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));</p>
<p>printf(“loading calibration…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_calib_create_from_path(factoryDir, &amp;calib));</p>
<p>printf(“loading acquisition context… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_acq_cont_create_from_calib(calib, &amp;acqCont));</p>
<p>printf(“load processing context n”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_create_from_calib(calib, &amp;procCont));</p>
<p>printf(“prepare saving of measurements… n”);
fflush(stdout);
CUVIS_EXPORTER cube_exporter;</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>strcpy(general_settings.export_dir, recDir);</p>
<p>CUVIS_EXPORT_CUBE_SETTINGS cube_settings;
cube_settings.allow_fragmentation = 0;
cube_settings.allow_overwrite = 1;
cube_settings.allow_session_file = 1;
cube_settings.fps = fps;
cube_settings.operation_mode = OperationMode_Internal;
cube_settings.allow_info_file = 1;
cube_settings.hard_limit = 4;
cube_settings.soft_limit = 2;</p>
<dl class="simple">
<dt>CUVIS_CHECK(cuvis_exporter_create_cube(</dt><dd><p>&amp;cube_exporter, general_settings, cube_settings));</p>
</dd>
</dl>
<p>CUVIS_PROC_ARGS procArgs;
procArgs.allow_recalib = 0;
procArgs.processing_mode = Cube_Raw;</p>
<p>CUVIS_SESSION_INFO sess = {“video”, 0, 0};
CUVIS_CHECK(cuvis_acq_cont_set_session_info(acqCont, &amp;sess));</p>
<p>printf(“waiting for camera to become online…n”);
fflush(stdout);</p>
<p>for (;;)
{</p>
<blockquote>
<div><p>CUVIS_HARDWARE_STATE state;
CUVIS_CHECK(cuvis_acq_cont_get_state(acqCont, &amp;state));</p>
<p>if (state == hardware_state_online)
{</p>
<blockquote>
<div><p>printf(”ncamera onlinen”);
fflush(stdout);</p>
<p>break;</p>
</div></blockquote>
<p>}
if (state == hardware_state_partially_online)
{</p>
<blockquote>
<div><p>printf(”ncamera partially onlinen”);
fflush(stdout);</p>
<p>break;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>#ifdef WIN32</dt><dd><p>Sleep(1000);</p>
</dd>
<dt>#else</dt><dd><p>usleep(1000000);</p>
</dd>
</dl>
<p>#endif</p>
<blockquote>
<div><blockquote>
<div><p>printf(“.”);</p>
</div></blockquote>
<p>}</p>
<p>printf(“component details:n”);
fflush(stdout);</p>
<p>CUVIS_INT compCount;
CUVIS_CHECK(cuvis_acq_cont_get_component_count(acqCont, &amp;compCount));
for (int compIdx = 0; compIdx &lt; compCount; compIdx++)
{</p>
<blockquote>
<div><p>CUVIS_INT online;
CUVIS_COMPONENT_INFO cinfo;</p>
<p>CUVIS_CHECK(cuvis_acq_cont_get_component_info(acqCont, compIdx, &amp;cinfo));
CUVIS_CHECK(cuvis_comp_online_get(acqCont, compIdx, &amp;online));
printf(” - component ‘%s’ is “, cinfo.displayname);
fflush(stdout);</p>
<p>if (online != 0)
{</p>
<blockquote>
<div><p>printf(“onlinen”);
fflush(stdout);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“offlinen”);
fflush(stdout);</p>
</div></blockquote>
<p>}
printf(” – info:        %sn”, cinfo.sensorinfo);
printf(” – use:         %sn”, cinfo.userfield);
printf(” – pixelformat: %sn”, cinfo.pixelformat);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>printf(“initializing hardware…n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_acq_cont_integration_time_set(acqCont, exposure_ms));
CUVIS_CHECK(</p>
<blockquote>
<div><p>cuvis_acq_cont_operation_mode_set(acqCont, OperationMode_Internal));</p>
</div></blockquote>
<p>CUVIS_CHECK(cuvis_acq_cont_fps_set(acqCont, fps));
CUVIS_CHECK(cuvis_acq_cont_queue_size_set(acqCont, 10));
CUVIS_CHECK(cuvis_acq_cont_continuous_set(acqCont, 0));
CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, procArgs));</p>
<p>cuvis_acq_cont_binning_set(acqCont, 1);
CUVIS_WORKER worker;
CUVIS_WORKER_SETTINGS worker_settings;
worker_settings.can_skip_measurements = 0;       // Worker cannot skip exporting measurements
worker_settings.can_skip_supplementary_steps = 1; // Worker can skip view generation
worker_settings.can_drop_results = 1;             // Worker can drop results from the output queue, if it is full
worker_settings.input_queue_size = 10;
worker_settings.output_queue_size = 5;
worker_settings.mandatory_queue_size = 2;
worker_settings.supplementary_queue_size = 2;
cuvis_worker_create(&amp;worker, worker_settings);</p>
<p>cuvis_worker_set_acq_cont(worker, acqCont);
cuvis_worker_set_proc_cont(worker, procCont);
cuvis_worker_set_exporter(worker, cube_exporter);</p>
<p>printf(“registering signal for CTRL+c (cancel recording) n”);
fflush(stdout);
signal(SIGINT, signal_handler);</p>
<p>printf(“recording…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_acq_cont_continuous_set(acqCont, 1));
CUVIS_CHECK(cuvis_worker_start(worker));</p>
<p>CUVIS_INT used_queue;
CUVIS_INT queue_limit;</p>
<p>while (0 != keepRunning)
{</p>
<blockquote>
<div><p>CUVIS_MESU mesu = 0;</p>
<p>queue_limit = 4;
cuvis_worker_get_threads_busy(worker, &amp;used_queue);
if (used_queue == queue_limit)
{</p>
<blockquote>
<div><p>printf(“Worker queue is full! Main() loop can not keep up!”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>cuvis_acq_cont_queue_size_get(acqCont, &amp;used_queue);
cuvis_acq_cont_queue_used_get(acqCont, &amp;used_queue);
if (used_queue == queue_limit)
{</p>
<blockquote>
<div><p>printf(“Acquisition queue is full! Worker can not keep up!”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>CUVIS_STATUS ret;
ret = cuvis_worker_get_next_result(worker, &amp;mesu, NULL, exposure_ms + 200);
if (ret == status_not_available) {</p>
<blockquote>
<div><p>printf(“Worker has no measurement ready yet…”);</p>
</div></blockquote>
<p>}
else if (ret != status_ok)
{</p>
<blockquote>
<div><p>printf(“Worker error, details: %sn”, cuvis_get_last_error_msg());
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>if (mesu)
{</p>
<blockquote>
<div><p>CUVIS_MESU_METADATA mesu_data;
CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(</p>
<blockquote>
<div><p>“rcurrent handle index: %04d”, mesu_data.session_info_sequence_no);</p>
</div></blockquote>
<p>fflush(stdout);</p>
<p>cuvis_measurement_free(&amp;mesu);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
signal(SIGINT, SIG_DFL);</p>
<p>printf(“cleaning upn”);
fflush(stdout);
CUVIS_CHECK(cuvis_acq_cont_continuous_set(acqCont, 0));
CUVIS_CHECK(cuvis_worker_stop(worker));
CUVIS_CHECK(cuvis_worker_drop_all_queued(worker));
cuvis_worker_free(&amp;worker);
cuvis_exporter_free(&amp;cube_exporter);
cuvis_acq_cont_free(&amp;acqCont);
cuvis_proc_cont_free(&amp;procCont);
cuvis_calib_free(&amp;calib);</p>
<p>cuvis_shutdown();
printf(“finished n”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-5-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-5-Qysr" name="Qysr" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;csignal&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;</p>
<p>using namespace std::literals::chrono_literals;</p>
<p>int keepRunning = 1;</p>
<p>void signal_handler(int sig)
{</p>
<blockquote>
<div><p>(void)sig;
std::cout &lt;&lt; std::endl</p>
<blockquote>
<div><p>&lt;&lt; “CTRL+C received. Stopping acquisiton…” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>keepRunning = 0;</p>
</div></blockquote>
<p>}</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 7)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; std::endl &lt;&lt; “Too few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “factory directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “name of recording directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “exposure time in ms” &lt;&lt; std::endl;
std::cout &lt;&lt; “auto exposure [1/0]” &lt;&lt; std::endl;
std::cout &lt;&lt; “target fps” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* userSettingsDir = argv[1];
char* factoryDir = argv[2];
char* recDir = argv[3];
char* exposureString = argv[4];
char* autoExpString = argv[5];
char* fpsString = argv[6];</p>
<p>int exposure_ms = std::stoi(exposureString);
bool autoExp = std::stoi(autoExpString);
double fps = std::stod(fpsString);</p>
<p>std::cout &lt;&lt; “Example 06 video cpp “ &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Factory Dir: “ &lt;&lt; factoryDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Recording Dir: “ &lt;&lt; recDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Exposure in ms: “ &lt;&lt; exposure_ms &lt;&lt; std::endl;
std::cout &lt;&lt; “Auto Exposure: “ &lt;&lt; autoExp &lt;&lt; std::endl;
std::cout &lt;&lt; “Target FPS: “ &lt;&lt; fps &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading user settings…” &lt;&lt; std::endl;</p>
<p>cuvis::General::init(userSettingsDir);</p>
<p>//register log message output
cuvis::General::register_log_callback(</p>
<blockquote>
<div><dl>
<dt>[](char const* msg, cuvis::loglevel_t lvl) -&gt; void {</dt><dd><dl class="simple">
<dt>static std::map&lt;cuvis::loglevel_t, std::string&gt; log_prefix = {</dt><dd><p>{loglevel_info, “info: “},
{loglevel_warning, “warning: “},
{loglevel_error, “error: “},
{loglevel_fatal, “fatal: “}};</p>
</dd>
</dl>
<p>std::cout &lt;&lt; “ - “ &lt;&lt; log_prefix.at(lvl) &lt;&lt; msg &lt;&lt; std::endl;</p>
</dd>
</dl>
<p>},
loglevel_info);</p>
</div></blockquote>
<p>std::cout &lt;&lt; “loading calibration…” &lt;&lt; std::endl;
cuvis::Calibration calib(factoryDir);</p>
<p>std::cout &lt;&lt; “loading acquisition context…” &lt;&lt; std::endl;
cuvis::AcquisitionContext acq(calib);
CUVIS_SESSION_INFO sess = {“video”, 0, 0};
acq.set_session_info(sess);</p>
<p>std::cout &lt;&lt; “prepare saving of measurements…” &lt;&lt; std::endl;
cuvis::SaveArgs sargs;
sargs.fps = fps;
sargs.operation_mode = OperationMode_Internal;
sargs.allow_overwrite = true;
sargs.allow_session_file = true;
sargs.export_dir = std::filesystem::path(recDir);</p>
<p>std::cout &lt;&lt; “Writing Files to: “ &lt;&lt; sargs.export_dir &lt;&lt; std::endl;
cuvis::CubeExporter exporter(sargs);</p>
<p>std::cout &lt;&lt; “prepare processing of measurements…” &lt;&lt; std::endl;
cuvis::ProcessingContext proc(calib);
cuvis::ProcessingArgs args;
args.processing_mode = Cube_Raw;
proc.set_processingArgs(args);</p>
<p>std::cout &lt;&lt; “waiting for camera to become online …”;
acq.register_state_change_callback(</p>
<blockquote>
<div><dl>
<dt>[](cuvis::hardware_state_t state,</dt><dd><blockquote>
<div><dl class="simple">
<dt>std::map&lt;int, cuvis::AcquisitionContext::component_state_info_t&gt;</dt><dd><p>comp_states) -&gt; void {</p>
</dd>
</dl>
</div></blockquote>
<p>std::cout &lt;&lt; std::endl;
switch (state)
{</p>
<blockquote>
<div><dl class="simple">
<dt>case hardware_state_online:</dt><dd><p>std::cout &lt;&lt; “camera online” &lt;&lt; std::endl;
break;</p>
</dd>
<dt>case hardware_state_partially_online:</dt><dd><p>std::cout &lt;&lt; “camera partially online” &lt;&lt; std::endl;
break;</p>
</dd>
<dt>case hardware_state_offline:</dt><dd><p>std::cout &lt;&lt; “camera offline” &lt;&lt; std::endl;
break;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>std::cout &lt;&lt; “ components: “ &lt;&lt; std::endl;
for (auto const&amp; comp : comp_states)
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “ #” &lt;&lt; comp.first &lt;&lt; “ “ &lt;&lt; comp.second.display_name</dt><dd><p>&lt;&lt; “ is “ &lt;&lt; (comp.second.is_online ? “online” : “offline”)
&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>});</p>
</div></blockquote>
<p>while (acq.get_state() == hardware_state_offline)
{</p>
<blockquote>
<div><p>std::this_thread::sleep_for(std::chrono::milliseconds(1000));
std::cout &lt;&lt; “.”;</p>
</div></blockquote>
<p>}
std::cout &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “initializing hardware…” &lt;&lt; std::endl;
acq.set_integration_time(exposure_ms).get();
acq.set_operation_mode(OperationMode_Internal).get();
acq.set_fps(fps).get();
acq.set_auto_exp(autoExp);
acq.set_continuous(true);</p>
<dl class="simple">
<dt>std::cout &lt;&lt; “registering signal for CTRL+c (cancel recording)…”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
<p>std::signal(SIGINT, signal_handler);</p>
<p>std::cout &lt;&lt; “configuring worker…” &lt;&lt; std::endl;
cuvis::WorkerArgs worker_settings;
worker_settings.can_skip_measurements = false; // Worker cannot skip exporting measurements
worker_settings.can_skip_supplementary_steps = true; // Worker can skip view generation
worker_settings.can_drop_results = true; // Worker can drop results from the output queue, if it is full
worker_settings.input_queue_size = 10;
worker_settings.output_queue_size = 5;
worker_settings.mandatory_queue_size = 2;
worker_settings.supplementary_queue_size = 2;</p>
<p>cuvis::Worker worker(worker_settings);
worker.set_acq_cont(&amp;acq);</p>
<p>//comment out the following line to prevent processing
worker.set_proc_cont(&amp;proc);</p>
<p>//comment out the following line to prevent saving to disk
worker.set_exporter(&amp;exporter);</p>
<p>std::cout &lt;&lt; “configuring FPS Analysis Stuff” &lt;&lt; std::endl;
using std::chrono::duration;
using std::chrono::duration_cast;
using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;
auto t1 = high_resolution_clock::now();
std::vector&lt;long long&gt; frametimes;
int fpsAveraging = 200;</p>
<p>std::cout &lt;&lt; “recording…! “ &lt;&lt; std::endl;
worker.start_processing();</p>
<p>while (0 != keepRunning)
{</p>
<blockquote>
<div><p>auto workerContainer = worker.get_next_result(100ms);
// maybe we’re already cancelling
if (keepRunning == 0)</p>
<blockquote>
<div><p>continue;</p>
</div></blockquote>
<p>if (workerContainer.mesu.has_value())
{</p>
<blockquote>
<div><p>auto t2 = t1;
t1 = high_resolution_clock::now();</p>
<dl class="simple">
<dt>std::cout</dt><dd><p>&lt;&lt; “current handle index: ”
&lt;&lt; workerContainer.mesu.value().get_meta()-&gt;session_info.sequence_no
&lt;&lt; std::endl;</p>
</dd>
</dl>
<p>auto ms_int = duration_cast&lt;milliseconds&gt;(t1 - t2);</p>
<p>if (frametimes.size() &gt;= fpsAveraging)
{</p>
<blockquote>
<div><p>frametimes.erase(frametimes.begin());</p>
</div></blockquote>
<p>}
frametimes.push_back(ms_int.count());
long long totalFrametime = 0;
for (int i = 0; i &lt; frametimes.size(); i++)
{</p>
<blockquote>
<div><p>totalFrametime += frametimes[i];</p>
</div></blockquote>
<p>}
double actualFps =</p>
<blockquote>
<div><p>1 / (((double)totalFrametime / (double)frametimes.size()) / 1000);</p>
</div></blockquote>
<dl class="simple">
<dt>if (abs(actualFps - fps) &gt; 0.5 &amp;&amp;</dt><dd><dl class="simple">
<dt>frametimes.size() ==</dt><dd><p>fpsAveraging) //fps is significantly different from user setting and averaging vector is full</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>std::cout &lt;&lt; “WARNING: FPS was set to “ &lt;&lt; fps</dt><dd><p>&lt;&lt; “ but on average we only get “ &lt;&lt; actualFps &lt;&lt; std::endl;</p>
</dd>
</dl>
</dd>
</dl>
<p>}
if (worker.get_threads_busy() == 4)
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “worker queue is full! Main() loop can not keep up!”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}
if (acq.get_queue_size() == acq.get_queue_used())
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “Acquisition queue is full! Worker can not keep up!”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>signal(SIGINT, SIG_DFL);
std::cout &lt;&lt; “acquisition stopped.” &lt;&lt; std::endl;
acq.set_continuous(false);
acq.reset_state_change_callback();
cuvis::General::shutdown();
cuvis::General::reset_log_callback();
std::cout &lt;&lt; std::endl &lt;&lt; “finished.” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-5-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-5-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
import time
from datetime import datetime, timedelta
from pathlib import Path</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_recordVideo(userSettingsDir,</dt><dd><blockquote>
<div><p>factoryDir,
recDir,
exposure,
autoExp,
fps):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<p>print(“loading calibration (factory)…”)
calibration = cuvis.Calibration(factoryDir)</p>
<p>print(“loading acquisition context…”)
acquisitionContext = cuvis.AcquisitionContext(calibration)
session_info = cuvis.SessionData(“video”, 0, 0)
acquisitionContext.session_info = session_info</p>
<p>print(“prepare saving of measurements…”)
saveArgs = cuvis.SaveArgs(export_dir=recDir,</p>
<blockquote>
<div><p>allow_overwrite=True,
allow_session_file=True,
fps=fps,
operation_mode=cuvis.OperationMode.Software)</p>
</div></blockquote>
<p>print(“writing files to: {}”.format(recDir))
cubeExporter = cuvis.CubeExporter(saveArgs)</p>
<p>print(“prepare processing of measurements…”)
processingContext = cuvis.ProcessingContext(calibration)
processingContext.processing_mode = cuvis.ProcessingMode.Raw</p>
<p>print(“Waiting for camera to come online…”)</p>
<dl class="simple">
<dt>while acquisitionContext.state == cuvis.HardwareState.Offline:</dt><dd><p>print(“.”, end=””)
time.sleep(1)</p>
</dd>
</dl>
<p>print(”n”)</p>
<p>print(“Component details:”)
for i, comp in enumerate(acquisitionContext.components()):</p>
<blockquote>
<div><dl class="simple">
<dt>print(“Component #{} {} is {}”.format(i, comp.info.display_name,</dt><dd><p>“online” if comp.online else “offline”))</p>
</dd>
</dl>
<p>print(” – info:        {}”.format(comp.info.sensor_info))
print(” – use:         {}”.format(comp.info.user_field))
print(” – pixelformat: {}”.format(comp.info.pixel_format))</p>
</div></blockquote>
<p>print(“initializing hardware…”)
acquisitionContext.integration_time = exposure
acquisitionContext.operation_mode = cuvis.OperationMode.Internal
acquisitionContext.fps = fps
acquisitionContext.auto_exp = autoExp
acquisitionContext.set_continuous(True)</p>
<p>print(“configuring worker…”)
workerSettings = cuvis.WorkerSettings()
worker = cuvis.Worker(workerSettings)
worker.set_acquisition_context(acquisitionContext)
worker.set_processing_context(processingContext)
worker.set_exporter(cubeExporter)
worker.start_processing()</p>
<p>print(“recording…! (will stop after 2 minutes)”)
start = datetime.now()
while (datetime.now() - start) &lt; timedelta(minutes=2):</p>
<blockquote>
<div><dl class="simple">
<dt>while 1:</dt><dd><dl class="simple">
<dt>if worker.has_next_result():</dt><dd><p>break</p>
</dd>
<dt>else:</dt><dd><p>time.sleep(0.001)</p>
</dd>
</dl>
</dd>
</dl>
<p>workerContainer = worker.get_next_result(1000)  # in ms
if workerContainer.mesu.data is not None:</p>
<blockquote>
<div><dl class="simple">
<dt>print(“current handle index: {}”.format(</dt><dd><p>workerContainer.mesu.session_info.sequence_number))</p>
</dd>
</dl>
<p>workerState = worker.state
if workerState.resultsInQueue == worker.output_queue_limit:</p>
<blockquote>
<div><p>print(“worker output queue is full! Main() loop can not keep up!”)
break</p>
</div></blockquote>
<dl class="simple">
<dt>if workerState.measurementsInQueue == worker.mandatory_queue_limit:</dt><dd><p>print(“acquisition queue is full! Worker can not keep up!”)
break</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>print(“acquisition stopped…”)
acquisitionContext.set_continuous(False)
worker.stop_processing()
cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl>
<dt>if platform.system() == “Windows”:</dt><dd><p>lib_dir = Path(os.getenv(“CUVIS”))
data_dir = lib_dir.parent / “sdk” / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><p>lib_dir = os.getenv(“CUVIS_DATA”)
data_dir = lib_dir / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
</dd>
</dl>
<p># default factory
loc_factory = lib_dir.parent / “factory”
# default settings
loc_settings = data_dir / “settings”</p>
<p># default output
loc_output = Path(os.getcwd()) / “EX06_video”</p>
<p># parameters
loc_exptime = 100  # in ms
loc_autoexp = False
loc_fps = 2</p>
<p>print(“Example 06: Record video file. Please provide:”)</p>
<dl class="simple">
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
</dl>
<p>factoryDir = input(“Factory directory (default: {}): “.format(loc_factory))
if factoryDir.strip().lower() in [“”, “default”]:</p>
<blockquote>
<div><p>factoryDir = loc_factory</p>
</div></blockquote>
<dl class="simple">
<dt>recDir = input(</dt><dd><p>“Name of recording directory (default: {}): “.format(loc_output))</p>
</dd>
<dt>if recDir.strip().lower() in [“”, “default”]:</dt><dd><p>recDir = loc_output</p>
</dd>
<dt>exposure = input(</dt><dd><p>“Exposure/Integration time in ms (default: {}): “.format(loc_exptime))</p>
</dd>
<dt>if exposure.strip().lower() in [“”, “default”]:</dt><dd><p>exposure = loc_exptime</p>
</dd>
</dl>
<p>exposure = int(exposure)</p>
<dl class="simple">
<dt>autoExp = input(</dt><dd><p>“Auto-exposure time [True/False] (default: {}): “.format(loc_autoexp))</p>
</dd>
<dt>if autoExp.strip().lower() in [“”, “default”]:</dt><dd><p>autoExp = loc_autoexp</p>
</dd>
</dl>
<p>autoExp = int(autoExp)</p>
<dl class="simple">
<dt>fps = input(</dt><dd><p>“Target frames per second (fps) (default: {}): “.format(loc_fps))</p>
</dd>
<dt>if fps.strip().lower() in [“”, “default”]:</dt><dd><p>fps = loc_fps</p>
</dd>
</dl>
<p>fps = int(fps)</p>
<dl class="simple">
<dt>run_example_recordVideo(str(userSettingsDir), str(factoryDir), str(recDir), exposure,</dt><dd><p>autoExp, fps)</p>
</dd>
</dl>
</div></blockquote>
</div></div>
</section>
<section id="rerecording-a-video-from-already-recorded-data">
<h2>Rerecording a video from already recorded data<a class="headerlink" href="#rerecording-a-video-from-already-recorded-data" title="Link to this heading"></a></h2>
<p>This example demonstrates how to load and process hyperspectral measurement data using the cuvis SDK.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-6-Qw==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-6-Qw==" name="Qw==" role="tab" tabindex="0">C</button><button aria-controls="panel-6-Qysr" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-6-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button><button aria-controls="panel-6-UHl0aG9u" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-6-UHl0aG9u" name="UHl0aG9u" role="tab" tabindex="-1">Python</button></div><div aria-labelledby="tab-6-Qw==" class="sphinx-tabs-panel group-tab" id="panel-6-Qw==" name="Qw==" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.h”</p>
<p>#include &lt;signal.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;</p>
<dl class="simple">
<dt>#ifdef WIN32</dt><dd><p>#include &lt;Windows.h&gt;</p>
</dd>
<dt>#else</dt><dd><p>#include &lt;unistd.h&gt;</p>
</dd>
</dl>
<p>#endif</p>
<p>int keepRunning = 1;</p>
<p>void signal_handler(int sig)
{</p>
<blockquote>
<div><p>printf(”nsignal received. Stopping acquisiton…n”);
fflush(stdout);
(void)sig;
keepRunning = 0;</p>
</div></blockquote>
<p>}</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 7)
{</p>
<blockquote>
<div><p>printf(“To few Arguments! Please provide:n”);
printf(“user settings directoryn”);
printf(“sessionfilen”);
printf(“name of recording directoryn”);
printf(“exposure time in msn”);
printf(“auto exposure [1/0]n”);
printf(“target fpsn”);
fflush(stdout);</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* const userSettingsDir = argv[1];
char* const sessionfile = argv[2];
char* const recDir = argv[3];
char* const exposureString = argv[4]; //in ms
char* const autoExpString = argv[5];
char* const fpsString = argv[6];</p>
<p>int exposure_ms = atoi(exposureString); //in ms
bool autoExp = false;
if (atoi(autoExpString) == 1)
{</p>
<blockquote>
<div><p>autoExp = true;</p>
</div></blockquote>
<p>}
double fps = atof(fpsString);</p>
<p>printf(“Example 06 video”);
printf(”nUser Settings Dir: “);
printf(userSettingsDir);
printf(”nSessionfile: “);
printf(sessionfile);
printf(”nRecording Dir: “);
printf(recDir);
printf(”nExposure in ms: %dn”, exposure_ms);
printf(“Auto Exposure: %dn”, autoExp);
printf(“Target FPS: %4.2fn”, fps);
fflush(stdout);</p>
<p>CUVIS_SESSION_FILE sessFile;
CUVIS_ACQ_CONT acqCont;
CUVIS_PROC_CONT procCont;</p>
<p>printf(“loading user settings…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_init(userSettingsDir, loglevel_debug));</p>
<p>printf(“loading session file… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_session_file_load(sessionfile, &amp;sessFile));</p>
<p>printf(“loading acquisition context… n”);
fflush(stdout);
CUVIS_CHECK(cuvis_acq_cont_create_from_session_file(sessFile, 1,</p>
<blockquote>
<div><p>&amp;acqCont)); // simulating = true –&gt; use frames from sessionfile instead of real camera</p>
</div></blockquote>
<p>printf(“load processing context n”);
fflush(stdout);
CUVIS_CHECK(cuvis_proc_cont_create_from_session_file(sessFile, &amp;procCont));</p>
<p>printf(“prepare saving of measurements… n”);
fflush(stdout);</p>
<p>CUVIS_EXPORTER cube_exporter;</p>
<dl class="simple">
<dt>CUVIS_EXPORT_GENERAL_SETTINGS general_settings = {</dt><dd><p>“”, //initializer list only takes const char*, leave empty and modify afterwards.
“all”,
1,
0.0,
pan_sharpening_interpolation_type_NearestNeighbor,
pan_sharpening_algorithm_Noop,
0,
0};</p>
</dd>
</dl>
<p>strcpy(general_settings.export_dir, recDir);</p>
<p>CUVIS_EXPORT_CUBE_SETTINGS cube_settings;
cube_settings.allow_fragmentation = 0;
cube_settings.allow_overwrite = 1;
cube_settings.allow_session_file = 1;
cube_settings.fps = fps;
cube_settings.operation_mode = OperationMode_Internal;
cube_settings.allow_info_file = 1;</p>
<p>CUVIS_CHECK(cuvis_exporter_create_cube(&amp;cube_exporter, general_settings, cube_settings));</p>
<p>CUVIS_PROC_ARGS procArgs;
procArgs.allow_recalib = 0;
procArgs.processing_mode = Cube_Raw;</p>
<p>CUVIS_SESSION_INFO sess = {“video”, 0, 0};
CUVIS_CHECK(cuvis_acq_cont_set_session_info(acqCont, &amp;sess));</p>
<p>printf(“waiting for simulated camera to become ready…n”);
fflush(stdout);
for (;;)
{</p>
<blockquote>
<div><p>CUVIS_HARDWARE_STATE state;
CUVIS_CHECK(cuvis_acq_cont_get_state(acqCont, &amp;state));</p>
<p>if (state == hardware_state_online)
{</p>
<blockquote>
<div><p>printf(”ncamera onlinen”);
fflush(stdout);</p>
<p>break;</p>
</div></blockquote>
<p>}
if (state == hardware_state_partially_online)
{</p>
<blockquote>
<div><p>printf(”ncamera partially onlinen”);
fflush(stdout);</p>
<p>break;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>#ifdef WIN32</dt><dd><p>Sleep(1000);</p>
</dd>
<dt>#else</dt><dd><p>usleep(1000000);</p>
</dd>
<dt>#endif</dt><dd><blockquote>
<div><p>printf(“.”);</p>
</div></blockquote>
<p>}</p>
<p>printf(“component details:n”);
fflush(stdout);
CUVIS_INT compCount;
CUVIS_CHECK(cuvis_acq_cont_get_component_count(acqCont, &amp;compCount));
for (int compIdx = 0; compIdx &lt; compCount; compIdx++)
{</p>
<blockquote>
<div><p>CUVIS_INT online;
CUVIS_COMPONENT_INFO cinfo;</p>
<p>CUVIS_CHECK(cuvis_acq_cont_get_component_info(acqCont, compIdx, &amp;cinfo));
CUVIS_CHECK(cuvis_comp_online_get(acqCont, compIdx, &amp;online));
printf(” - component ‘%s’ is “, cinfo.displayname);
fflush(stdout);</p>
<p>if (online != 0)
{</p>
<blockquote>
<div><p>printf(“onlinen”);
fflush(stdout);</p>
</div></blockquote>
<p>}
else
{</p>
<blockquote>
<div><p>printf(“offlinen”);
fflush(stdout);</p>
</div></blockquote>
<p>}
printf(” – info:        %sn”, cinfo.sensorinfo);
printf(” – use:         %sn”, cinfo.userfield);
printf(” – pixelformat: %sn”, cinfo.pixelformat);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>printf(“initializing hardware…n”);
fflush(stdout);</p>
<p>CUVIS_CHECK(cuvis_acq_cont_integration_time_set(acqCont, 100));
CUVIS_CHECK(cuvis_acq_cont_operation_mode_set(acqCont, OperationMode_Internal));
CUVIS_CHECK(cuvis_acq_cont_fps_set(acqCont, fps));
CUVIS_CHECK(cuvis_acq_cont_queue_size_set(acqCont, 10));
CUVIS_CHECK(cuvis_acq_cont_continuous_set(acqCont, 0));
CUVIS_CHECK(cuvis_proc_cont_set_args(procCont, procArgs));</p>
<p>cuvis_acq_cont_binning_set(acqCont, 1);
CUVIS_WORKER worker;
CUVIS_WORKER_SETTINGS worker_settings;
worker_settings.can_skip_measurements = 0;        // Worker cannot skip exporting measurements
worker_settings.can_skip_supplementary_steps = 1; // Worker can skip view generation
worker_settings.can_drop_results = 1;             // Worker can drop results from the output queue, if it is full
worker_settings.input_queue_size = 10;
worker_settings.output_queue_size = 5;
worker_settings.mandatory_queue_size = 2;
worker_settings.supplementary_queue_size = 2;
cuvis_worker_create(&amp;worker, worker_settings);</p>
<p>cuvis_worker_set_acq_cont(worker, acqCont);
cuvis_worker_set_proc_cont(worker, procCont);
cuvis_worker_set_exporter(worker, cube_exporter);</p>
<p>printf(“registering signal for CTRL+c (cancel recording) n”);
fflush(stdout);
signal(SIGINT, signal_handler);</p>
<p>printf(“recording…n”);
fflush(stdout);
CUVIS_CHECK(cuvis_acq_cont_continuous_set(acqCont, 1));
CUVIS_CHECK(cuvis_worker_start(worker));</p>
<p>CUVIS_INT used_queue;
CUVIS_INT queue_limit;</p>
<p>while (0 != keepRunning)
{</p>
<blockquote>
<div><p>CUVIS_MESU mesu = 0;</p>
<p>queue_limit = worker_settings.mandatory_queue_size + worker_settings.supplementary_queue_size;
cuvis_worker_get_threads_busy(worker, &amp;used_queue);
if (used_queue == queue_limit)
{</p>
<blockquote>
<div><p>printf(“Worker queue is full! Main() loop can not keep up!”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>cuvis_acq_cont_queue_size_get(acqCont, &amp;used_queue);
cuvis_acq_cont_queue_used_get(acqCont, &amp;used_queue);
if (used_queue == queue_limit)
{</p>
<blockquote>
<div><p>printf(“Acquisition queue is full! Worker can not keep up!”);
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>CUVIS_STATUS ret = cuvis_worker_get_next_result(acqCont, &amp;mesu, NULL, 1000);
if (ret == status_not_available)
{</p>
<blockquote>
<div><p>printf(“Worker has no measurement ready yet…”);</p>
</div></blockquote>
<p>}
else if (ret != status_ok)
{</p>
<blockquote>
<div><p>printf(“Worker error, details: %sn”, cuvis_get_last_error_msg());
fflush(stdout);</p>
</div></blockquote>
<p>}</p>
<p>if (mesu)
{</p>
<blockquote>
<div><p>CUVIS_MESU_METADATA mesu_data;
CUVIS_CHECK(cuvis_measurement_get_metadata(mesu, &amp;mesu_data));
printf(”rcurrent handle index: %04d”, mesu_data.session_info_sequence_no);
fflush(stdout);</p>
<p>cuvis_measurement_free(&amp;mesu);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
signal(SIGINT, SIG_DFL);</p>
<p>printf(“cleaning upn”);
fflush(stdout);
CUVIS_CHECK(cuvis_acq_cont_continuous_set(acqCont, 0));
CUVIS_CHECK(cuvis_worker_stop(worker));
CUVIS_CHECK(cuvis_worker_drop_all_queued(worker));
cuvis_worker_free(&amp;worker);
cuvis_exporter_free(&amp;cube_exporter);
cuvis_acq_cont_free(&amp;acqCont);
cuvis_proc_cont_free(&amp;procCont);
cuvis_session_file_free(&amp;sessFile);</p>
<p>cuvis_shutdown();
printf(“finished n”);
fflush(stdout);</p>
</dd>
</dl>
<p>}</p>
</div><div aria-labelledby="tab-6-Qysr" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-6-Qysr" name="Qysr" role="tabpanel" tabindex="0"><blockquote>
<div></div></blockquote>
<p>#include “cuvis.hpp”</p>
<p>#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;csignal&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;</p>
<p>using namespace std::literals::chrono_literals;</p>
<p>int keepRunning = 1;</p>
<p>void signal_handler(int sig)
{</p>
<blockquote>
<div><p>(void)sig;
std::cout &lt;&lt; std::endl</p>
<blockquote>
<div><p>&lt;&lt; “CTRL+C received. Stopping acquisiton…” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>keepRunning = 0;</p>
</div></blockquote>
<p>}</p>
<p>int main(int argc, char* argv[])
{</p>
<blockquote>
<div><p>if (argc != 7)
{</p>
<blockquote>
<div><p>std::cout &lt;&lt; std::endl &lt;&lt; “To few Arguments! Please provide:” &lt;&lt; std::endl;
std::cout &lt;&lt; “user settings directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “sessionfile” &lt;&lt; std::endl;
std::cout &lt;&lt; “name of recording directory” &lt;&lt; std::endl;
std::cout &lt;&lt; “exposure time in ms” &lt;&lt; std::endl;
std::cout &lt;&lt; “auto exposure [1/0]” &lt;&lt; std::endl;
std::cout &lt;&lt; “target fps” &lt;&lt; std::endl;</p>
<p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>char* userSettingsDir = argv[1];
char* sessionfile = argv[2];
char* recDir = argv[3];
char* exposureString = argv[4];
char* autoExpString = argv[5];
char* fpsString = argv[6];</p>
<p>int exposure_ms = std::stoi(exposureString);
bool autoExp = std::stoi(autoExpString);
double fps = std::stod(fpsString);</p>
<p>std::cout &lt;&lt; “Example 06 video cpp “ &lt;&lt; std::endl;
std::cout &lt;&lt; “User Settings Dir: “ &lt;&lt; userSettingsDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Sessionfile: “ &lt;&lt; sessionfile &lt;&lt; std::endl;
std::cout &lt;&lt; “Recording Dir: “ &lt;&lt; recDir &lt;&lt; std::endl;
std::cout &lt;&lt; “Exposure in ms: “ &lt;&lt; exposure_ms &lt;&lt; std::endl;
std::cout &lt;&lt; “Auto Exposure: “ &lt;&lt; autoExp &lt;&lt; std::endl;
std::cout &lt;&lt; “Target FPS: “ &lt;&lt; fps &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “loading user settings…” &lt;&lt; std::endl;</p>
<p>cuvis::General::init(userSettingsDir);</p>
<p>//register log message output
cuvis::General::register_log_callback(</p>
<blockquote>
<div><dl>
<dt>[](char const* msg, cuvis::loglevel_t lvl) -&gt; void {</dt><dd><dl class="simple">
<dt>static std::map&lt;cuvis::loglevel_t, std::string&gt; log_prefix = {</dt><dd><p>{loglevel_info, “info: “},
{loglevel_warning, “warning: “},
{loglevel_error, “error: “},
{loglevel_fatal, “fatal: “}};</p>
</dd>
</dl>
<p>std::cout &lt;&lt; “ - “ &lt;&lt; log_prefix.at(lvl) &lt;&lt; msg &lt;&lt; std::endl;</p>
</dd>
</dl>
<p>},
loglevel_info);</p>
</div></blockquote>
<p>std::cout &lt;&lt; “loading sessionfile…” &lt;&lt; std::endl;
cuvis::SessionFile sess(sessionfile);</p>
<p>std::cout &lt;&lt; “loading acquisition context…” &lt;&lt; std::endl;
cuvis::AcquisitionContext acq(</p>
<blockquote>
<div><p>sess,
true); // simulating = true –&gt; use frames from sessionfile instead of real camera</p>
</div></blockquote>
<p>CUVIS_SESSION_INFO sessinfo = {“video”, 0, 0};
acq.set_session_info(sessinfo);</p>
<p>std::cout &lt;&lt; “prepare saving of measurements…” &lt;&lt; std::endl;
cuvis::SaveArgs sargs;
sargs.fps = fps;
sargs.operation_mode = OperationMode_Internal;
sargs.allow_overwrite = true;
sargs.allow_session_file = true;
sargs.export_dir = std::filesystem::path(recDir);</p>
<p>std::cout &lt;&lt; “Writing Files to: “ &lt;&lt; sargs.export_dir &lt;&lt; std::endl;
cuvis::CubeExporter exporter(sargs);</p>
<p>std::cout &lt;&lt; “prepare processing of measurements…” &lt;&lt; std::endl;
cuvis::ProcessingContext proc(sess);
cuvis::ProcessingArgs args;
args.processing_mode = Cube_Raw;
proc.set_processingArgs(args);</p>
<p>std::cout &lt;&lt; “waiting for camera to become online …”;
acq.register_state_change_callback(</p>
<blockquote>
<div><dl>
<dt>[](cuvis::hardware_state_t state,</dt><dd><blockquote>
<div><dl class="simple">
<dt>std::map&lt;int, cuvis::AcquisitionContext::component_state_info_t&gt;</dt><dd><p>comp_states) -&gt; void {</p>
</dd>
</dl>
</div></blockquote>
<p>std::cout &lt;&lt; std::endl;
switch (state)
{</p>
<blockquote>
<div><dl class="simple">
<dt>case hardware_state_online:</dt><dd><p>std::cout &lt;&lt; “camera online” &lt;&lt; std::endl;
break;</p>
</dd>
<dt>case hardware_state_partially_online:</dt><dd><p>std::cout &lt;&lt; “camera partially online” &lt;&lt; std::endl;
break;</p>
</dd>
<dt>case hardware_state_offline:</dt><dd><p>std::cout &lt;&lt; “camera offline” &lt;&lt; std::endl;
break;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>std::cout &lt;&lt; “ components: “ &lt;&lt; std::endl;
for (auto const&amp; comp : comp_states)
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “ #” &lt;&lt; comp.first &lt;&lt; “ “ &lt;&lt; comp.second.display_name</dt><dd><p>&lt;&lt; “ is “ &lt;&lt; (comp.second.is_online ? “online” : “offline”)
&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>});</p>
</div></blockquote>
<p>while (acq.get_state() == hardware_state_offline)
{</p>
<blockquote>
<div><p>std::this_thread::sleep_for(std::chrono::milliseconds(1000));
std::cout &lt;&lt; “.”;</p>
</div></blockquote>
<p>}
std::cout &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; “initializing simulated hardware…” &lt;&lt; std::endl;
acq.set_integration_time(exposure_ms).get();
acq.set_operation_mode(OperationMode_Internal).get();
acq.set_fps(fps).get();
acq.set_auto_exp(autoExp);
acq.set_continuous(true);</p>
<dl class="simple">
<dt>std::cout &lt;&lt; “registering signal for CTRL+c (cancel recording)…”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
<p>std::signal(SIGINT, signal_handler);</p>
<p>std::cout &lt;&lt; “configuring worker…” &lt;&lt; std::endl;
cuvis::WorkerArgs worker_settings;
worker_settings.can_skip_measurements = false;       // Worker cannot skip exporting measurements
worker_settings.can_skip_supplementary_steps = true; // Worker can skip view generation
worker_settings.can_drop_results = true;             // Worker can drop results from the output queue, if it is full
worker_settings.input_queue_size = 10;
worker_settings.output_queue_size = 5;
worker_settings.mandatory_queue_size = 2;
worker_settings.supplementary_queue_size = 2;
cuvis::Worker worker(worker_settings);
worker.set_acq_cont(&amp;acq);</p>
<p>//comment out the following line to prevent processing
worker.set_proc_cont(&amp;proc);</p>
<p>//comment out the following line to prevent saving to disk
worker.set_exporter(&amp;exporter);</p>
<p>std::cout &lt;&lt; “configuring FPS Analysis Stuff” &lt;&lt; std::endl;
using std::chrono::duration;
using std::chrono::duration_cast;
using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;
auto t1 = high_resolution_clock::now();
std::vector&lt;long long&gt; frametimes;
int fpsAveraging = 200;</p>
<p>std::cout &lt;&lt; “recording…! “ &lt;&lt; std::endl;
worker.start_processing();</p>
<p>while (keepRunning)
{</p>
<blockquote>
<div><p>auto workerContainer = worker.get_next_result(100ms);
if (workerContainer.mesu.has_value())
{</p>
<blockquote>
<div><p>auto t2 = t1;
t1 = high_resolution_clock::now();</p>
<dl class="simple">
<dt>std::cout</dt><dd><p>&lt;&lt; “current handle index: ”
&lt;&lt; workerContainer.mesu.value().get_meta()-&gt;session_info.sequence_no
&lt;&lt; std::endl;</p>
</dd>
</dl>
<p>auto ms_int = duration_cast&lt;milliseconds&gt;(t1 - t2);</p>
<p>if (frametimes.size() &gt;= fpsAveraging)
{</p>
<blockquote>
<div><p>frametimes.erase(frametimes.begin());</p>
</div></blockquote>
<p>}
frametimes.push_back(ms_int.count());
long long totalFrametime = 0;
for (int i = 0; i &lt; frametimes.size(); i++)
{</p>
<blockquote>
<div><p>totalFrametime += frametimes[i];</p>
</div></blockquote>
<p>}
double actualFps =</p>
<blockquote>
<div><p>1 / (((double)totalFrametime / (double)frametimes.size()) / 1000);</p>
</div></blockquote>
<dl class="simple">
<dt>if (abs(actualFps - fps) &gt; 0.5 &amp;&amp;</dt><dd><dl class="simple">
<dt>frametimes.size() ==</dt><dd><p>fpsAveraging) //fps is significantly different from user setting and averaging vector is full</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>std::cout &lt;&lt; “WARNING: FPS was set to “ &lt;&lt; fps</dt><dd><p>&lt;&lt; “ but on average we only get “ &lt;&lt; actualFps &lt;&lt; std::endl;</p>
</dd>
</dl>
</dd>
</dl>
<p>}
if (worker.get_threads_busy() == 4)
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “worker queue is full! Main() loop can not keep up!”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}
if (acq.get_queue_size() == acq.get_queue_used())
{</p>
<blockquote>
<div><dl class="simple">
<dt>std::cout &lt;&lt; “Acquisition queue is full! Worker can not keep up!”</dt><dd><p>&lt;&lt; std::endl;</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>signal(SIGINT, SIG_DFL);
std::cout &lt;&lt; “acquisition stopped.” &lt;&lt; std::endl;
acq.set_continuous(false);
worker.stop_processing();
worker.drop_all_queued();
acq.reset_state_change_callback();
cuvis::General::reset_log_callback();
cuvis::General::shutdown();
std::cout &lt;&lt; std::endl &lt;&lt; “finished.” &lt;&lt; std::endl;</p>
</div></blockquote>
<p>}</p>
</div><div aria-labelledby="tab-6-UHl0aG9u" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-6-UHl0aG9u" name="UHl0aG9u" role="tabpanel" tabindex="0"><p>import os
import platform
import time
from datetime import datetime, timedelta
from pathlib import Path</p>
<p>import cuvis</p>
<dl>
<dt>def run_example_recordVideoFromSessionFile(userSettingsDir,</dt><dd><blockquote>
<div><p>measurementLoc,
recDir,
exposure,
autoExp,
fps):</p>
</div></blockquote>
<p>print(“loading user settings…”)
cuvis.init(userSettingsDir)
cuvis.set_log_level(“info”)</p>
<p>print(“loading session file …”)
session = cuvis.SessionFile(measurementLoc)</p>
<p>print(“loading acquisition context…”)
acquisitionContext = cuvis.AcquisitionContext(session, simulate=True)  #
# using images from session file instead of camera
session_info = cuvis.SessionData(“video”, 0, 0)
acquisitionContext.session_info = session_info</p>
<p>print(“prepare saving of measurements…”)
saveArgs = cuvis.SaveArgs(export_dir=recDir,</p>
<blockquote>
<div><p>allow_overwrite=True,
allow_session_file=True,
fps=fps,
operation_mode=cuvis.OperationMode.Internal)</p>
</div></blockquote>
<p>print(“writing files to: {}”.format(recDir))
cubeExporter = cuvis.CubeExporter(saveArgs)</p>
<p>print(“prepare processing of measurements…”)
processingContext = cuvis.ProcessingContext(session)
processingContext.processing_mode = cuvis.ProcessingMode.Raw</p>
<p>print(“Waiting for camera to come online…”)</p>
<dl class="simple">
<dt>while acquisitionContext.state == cuvis.HardwareState.Offline:</dt><dd><p>print(“.”, end=””)
time.sleep(1)</p>
</dd>
</dl>
<p>print(”n”)</p>
<p>print(“Component details:”)
print(“Component details:”)
for i, (info, is_online) in enumerate(acquisitionContext.components()):</p>
<blockquote>
<div><dl class="simple">
<dt>print(“Component #{} {} is {}”.format(i, info.display_name,</dt><dd><p>“online” if is_online else “offline”))</p>
</dd>
</dl>
<p>print(” – info:        {}”.format(info.sensor_info))
print(” – use:         {}”.format(info.user_field))
print(” – pixelformat: {}”.format(info.pixel_format))</p>
</div></blockquote>
<p>print(“initializing simulated hardware…”)
acquisitionContext.integration_time = exposure
acquisitionContext.operation_mode = cuvis.OperationMode.Internal
acquisitionContext.fps = fps
acquisitionContext.auto_exp = autoExp
acquisitionContext.set_continuous(True)</p>
<p>print(“configuring worker…”)
workerSettings = cuvis.WorkerSettings()
worker = cuvis.Worker(workerSettings)
worker.set_acquisition_context(acquisitionContext)
worker.set_processing_context(processingContext)
worker.set_exporter(cubeExporter)
worker.start_processing()</p>
<p>print(“recording…! (will stop after 2 minutes)”)
start = datetime.now()
while (datetime.now() - start) &lt; timedelta(minutes=2):</p>
<blockquote>
<div><dl class="simple">
<dt>while 1:</dt><dd><dl class="simple">
<dt>if worker.has_next_result():</dt><dd><p>break</p>
</dd>
<dt>else:</dt><dd><p>time.sleep(0.001)</p>
</dd>
</dl>
</dd>
</dl>
<p>workerContainer = worker.get_next_result(0)
if workerContainer.mesu.data is not None:</p>
<blockquote>
<div><dl class="simple">
<dt>print(“current handle index: {}”.format(</dt><dd><p>workerContainer.mesu.session_info.sequence_number))</p>
</dd>
</dl>
<p>workerState = worker.state
if workerState.resultsInQueue == worker.output_queue_limit:</p>
<blockquote>
<div><p>print(“worker output queue is full! Main() loop can not keep up!”)
break</p>
</div></blockquote>
<dl class="simple">
<dt>if workerState.measurementsInQueue == worker.mandatory_queue_limit:</dt><dd><p>print(“acquisition queue is full! Worker can not keep up!”)
break</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>print(“acquisition stopped…”)
acquisitionContext.set_continuous(False)
worker.stop_processing()
cuvis.shutdown()
print(“finished.”)</p>
</dd>
</dl>
<p>if __name__ == “__main__”:</p>
<blockquote>
<div><dl>
<dt>if platform.system() == “Windows”:</dt><dd><p>lib_dir = Path(os.getenv(“CUVIS”))
data_dir = lib_dir.parent / “sdk” / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
</dd>
<dt>elif platform.system() == “Linux”:</dt><dd><p>lib_dir = os.getenv(“CUVIS_DATA”)
data_dir = lib_dir / </p>
<blockquote>
<div><p>“sample_data” / “set_examples”</p>
</div></blockquote>
</dd>
</dl>
<p># default video
loc_file = data_dir / “set1_video” / “video.cu3s”
# default settings
loc_settings = data_dir / “settings”</p>
<p># default output
loc_output = Path(os.getcwd()) / “EX07_video”</p>
<p># parameters
loc_exptime = 100  # in ms
loc_autoexp = False
loc_fps = 2</p>
<p>print(“Example 07: Record video from session file. Please provide:”)</p>
<dl class="simple">
<dt>userSettingsDir = input(</dt><dd><p>“User settings directory (default: {}): “.format(loc_settings))</p>
</dd>
<dt>if userSettingsDir.strip().lower() in [“”, “default”]:</dt><dd><p>userSettingsDir = loc_settings</p>
</dd>
<dt>factoryDir = input(“Session file (default: {}): “.format(</dt><dd><p>loc_file))</p>
</dd>
<dt>if factoryDir.strip().lower() in [“”, “default”]:</dt><dd><p>factoryDir = loc_file</p>
</dd>
<dt>recDir = input(</dt><dd><p>“Name of recording directory (default: {}): “.format(loc_output))</p>
</dd>
<dt>if recDir.strip().lower() in [“”, “default”]:</dt><dd><p>recDir = loc_output</p>
</dd>
<dt>exposure = input(</dt><dd><p>“Exposure/Integration time in ms (default: {}): “.format(loc_exptime))</p>
</dd>
<dt>if exposure.strip().lower() in [“”, “default”]:</dt><dd><p>exposure = loc_exptime</p>
</dd>
</dl>
<p>exposure = int(exposure)</p>
<dl class="simple">
<dt>autoExp = input(</dt><dd><p>“Auto-exposure time [True/False] (default: {}): “.format(loc_autoexp))</p>
</dd>
<dt>if autoExp.strip().lower() in [“”, “default”]:</dt><dd><p>autoExp = loc_autoexp</p>
</dd>
<dt>fps = input(</dt><dd><p>“Target frames per second (fps) (default: {}): “.format(loc_fps))</p>
</dd>
<dt>if fps.strip().lower() in [“”, “default”]:</dt><dd><p>fps = loc_fps</p>
</dd>
</dl>
<p>fps = int(fps)</p>
<dl class="simple">
<dt>run_example_recordVideoFromSessionFile(str(userSettingsDir), str(factoryDir), str(recDir), exposure,</dt><dd><p>autoExp, fps)</p>
</dd>
</dl>
</div></blockquote>
</div></div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sdkuserguide.html" class="btn btn-neutral float-left" title="SDK User’s Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cwrapper.html" class="btn btn-neutral float-right" title="Cuvis C API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Cubert GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>